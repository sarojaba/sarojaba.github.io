{"meta":{"title":"사로자바의 블로그","subtitle":"소프트웨어 개발","description":"공부한 내용들을 정리하는 곳","author":"사로자바","url":"http://sarojaba.github.io"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2017-04-08T17:15:07.522Z","updated":"2017-04-08T17:15:07.522Z","comments":true,"path":"2017/04/09/hello-world/","link":"","permalink":"http://sarojaba.github.io/2017/04/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"reverse-array-recursively","slug":"reverse-array-recursively","date":"2015-07-19T15:48:00.000Z","updated":"2017-04-09T03:04:30.864Z","comments":true,"path":"2015/07/20/reverse-array-recursively/","link":"","permalink":"http://sarojaba.github.io/2015/07/20/reverse-array-recursively/","excerpt":"","text":"Source code#include &lt;iostream&gt; using namespace std; void reverse(int *A, int N, int i, int j) { // base case if(i &gt;= j) return; // swap int t = A[i]; A[i] = A[j]; A[j] = t; // recursive reverse(A, N, ++i, --j); } void reverse(int *A, int N) { reverse(A, N, 0, N-1); } int main() { // your code goes here int A[5] = {1, 2, 3, 4, 5}; reverse(A, 5); for(int i = 0; i &lt; 5; i++) { cout &lt;&lt; A[i] &lt;&lt; &quot;,&quot;; } cout &lt;&lt; endl; return 0; }","categories":[],"tags":[]},{"title":"back-to-high-school-physics","slug":"back-to-high-school-physics","date":"2015-06-17T01:23:00.000Z","updated":"2017-04-09T03:12:44.131Z","comments":true,"path":"2015/06/17/back-to-high-school-physics/","link":"","permalink":"http://sarojaba.github.io/2015/06/17/back-to-high-school-physics/","excerpt":"","text":"A particle has initial velocity and constant acceleration. If its velocity after certain time is v then what will its displacement be in twice of that time? InputThe input will contain two integers in each line. Each line makes one set of input. These two integers denote the value of v (-100 &lt;= v &lt;= 100) and t(0&lt;=t&lt;= 200) ( t means at the time the particle gains that velocity) OutputFor each line of input print a single integer in one line denoting the displacement in double of that time. Sample Input0 05 12 Sample Output0120 Source Codeint main(int argc, char** argv) { int v, t; while(cin &gt;&gt; v) { cin &gt;&gt; t; cout &lt;&lt; v * t * 2 &lt;&lt; endl; } } Referencehttp://uva.onlinejudge.org/external/100/10071.html","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"UVa","slug":"UVa","permalink":"http://sarojaba.github.io/tags/UVa/"},{"name":"Back To High School Physics","slug":"Back-To-High-School-Physics","permalink":"http://sarojaba.github.io/tags/Back-To-High-School-Physics/"}]},{"title":"연속-부분-최대곱-public-class-max-public-static","slug":"연속-부분-최대곱-public-class-max-public-static","date":"2015-06-17T01:19:00.000Z","updated":"2017-04-09T03:14:28.689Z","comments":true,"path":"2015/06/17/연속-부분-최대곱-public-class-max-public-static/","link":"","permalink":"http://sarojaba.github.io/2015/06/17/연속-부분-최대곱-public-class-max-public-static/","excerpt":"","text":"연속 부분 최대곱public class MAX{ public static double[] nums = {1.1, 0.7, 1.3, 0.9, 1.4, 0.8, 0.7, 1.4}; public static void main(String[] args){ float max = 1; for(int i = 0; i &lt; nums.length; i++){ if(nums[i] &gt; 1){ float m = 1; for(int j = 0; j &lt; nums.length - i; j++){ m *= nums[i + j]; if(max &lt; m){ max = m; } } } } System.out.println(max); } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"연속 부분 최대곱","slug":"연속-부분-최대곱","permalink":"http://sarojaba.github.io/tags/연속-부분-최대곱/"}]},{"title":"후위-표현식","slug":"후위-표현식","date":"2015-06-07T15:34:00.000Z","updated":"2017-04-09T03:16:13.158Z","comments":true,"path":"2015/06/08/후위-표현식/","link":"","permalink":"http://sarojaba.github.io/2015/06/08/후위-표현식/","excerpt":"","text":"중위 표현식을 후위 표현식으로 변경하라.ex) 5 + (4 - 2) - 3 2 === 5 4 2 - + 3 2 - import java.util.*; public class Postfix{ public static void main(String[] args){ String expression = &quot;5+(4-2)-3*2&quot;; Stack stack = new Stack(); StringBuilder sb = new StringBuilder(); for(int i = 0; i &lt; expression.length(); i++){ char c = expression.charAt(i); switch(c){ case &apos;0&apos;: case &apos;1&apos;: case &apos;2&apos;: case &apos;3&apos;: case &apos;4&apos;: case &apos;5&apos;: case &apos;6&apos;: case &apos;7&apos;: case &apos;8&apos;: case &apos;9&apos;: sb.append(c); break; case &apos;+&apos;: case &apos;-&apos;: case &apos;*&apos;: case &apos;/&apos;: if(!stack.empty() &amp;&amp; (stack.peek() != &apos;(&apos;)){ if(order(stack.peek()) &lt;= order(c)){ sb.append(stack.pop()); } } stack.push(c); break; case &apos;(&apos;: stack.push(c); break; case &apos;)&apos;: char op; while((op = stack.pop()) != &apos;(&apos;){ sb.append(op); } break; default: System.out.println(&quot;Error&quot;); return; } } while(!stack.empty()){ sb.append(stack.pop()); } System.out.println(sb.toString()); } public static int order(char op){ switch(op){ case &apos;*&apos;: case &apos;/&apos;: return 1; case &apos;+&apos;: case &apos;-&apos;: return 2; default: return 0; } } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"후위 표현식","slug":"후위-표현식","permalink":"http://sarojaba.github.io/tags/후위-표현식/"}]},{"title":"1과-2의-합","slug":"1과-2의-합","date":"2015-06-04T11:36:00.000Z","updated":"2017-04-09T03:16:43.985Z","comments":true,"path":"2015/06/04/1과-2의-합/","link":"","permalink":"http://sarojaba.github.io/2015/06/04/1과-2의-합/","excerpt":"","text":"어떤 정수 n이 있다. 이 정수를 1과 2의 합의 순서로 표현할 때 나타낼 수 있는 방법의 수를 구하시오. 예를 들어 n=3 이면3 = 1 + 1 + 1 = 1 + 2 = 2 + 1단, 1 + 2 와 2 + 1은 그 operand는 같지만 순서가 다르므로 다른것으로 친다. public class Sum{ public static void main(String[] args){ System.out.println(fibonacci(5)); } public static int fibonacci(int num){ if(num == 1){ return 1; } if(num == 2){ return 2; } return fibonacci(num - 2) + fibonacci(num - 1); } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"1과 2의 합","slug":"1과-2의-합","permalink":"http://sarojaba.github.io/tags/1과-2의-합/"}]},{"title":"바이러스","slug":"바이러스","date":"2015-06-04T11:33:00.000Z","updated":"2017-04-09T03:21:38.430Z","comments":true,"path":"2015/06/04/바이러스/","link":"","permalink":"http://sarojaba.github.io/2015/06/04/바이러스/","excerpt":"","text":"바이러스가 1마리 있다. 이 바이러스의 수는 1초 후에 2배로 불어날 수도 있고 1/3(소숫점 이하 버림)로 줄 수도 있다. 현재 몇 마리의 바이러스가 존재하는지 주어질 때 1마리의 바이러스에서부터 최소 몇 초의 시간이 흘러 현재 상태가 되었는지 구하시오. ex) 현재 바이러스가 7마리 있다면,1 -&gt; 2 -&gt; 4 -&gt; 8 -&gt; 16 -&gt; 32 -&gt; 64 -&gt; 21 -&gt; 7이보다 더 빠른 시간 안에 7마리가 될 수는 없다.따라서 답은 8초이다. import java.util.*; public class Virus{ public static void main(String[] args){ int num = 7; Queue queue = new LinkedList(); queue.add(new Element(1, 0)); while(true){ Element e = queue.remove(); if(e.getNum() == num){ System.out.println(e.getTime()); return; } queue.add(new Element(e.getNum() * 2, e.getTime() + 1)); queue.add(new Element(e.getNum() / 3, e.getTime() + 1)); } } class Element{ private int num; private int time; public Element(int num, int time){ this.num = num; this.time = time; } public int getNum(){ return num; } public int getTime(){ return time; } } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"바이러스","slug":"바이러스","permalink":"http://sarojaba.github.io/tags/바이러스/"}]},{"title":"java-iterator-pattern-on-colletions","slug":"java-iterator-pattern-on-colletions","date":"2015-02-16T11:18:00.000Z","updated":"2017-04-09T03:25:10.433Z","comments":true,"path":"2015/02/16/java-iterator-pattern-on-colletions/","link":"","permalink":"http://sarojaba.github.io/2015/02/16/java-iterator-pattern-on-colletions/","excerpt":"","text":"The Iterator patternIterator 패턴은 Collection을 탐색하는 방법과 클라이언트가 수행할 작업을 분리하는 GoF의 패턴 중 하나입니다. index, cursor, enumeration 등으로도 불립니다. Iterator는 Active 또는 Passive한 형태로 나뉩니다. Active Iterator는 클라이언트가 Iterator를 생성하고, 다음 아이템의 존재 여부를 확인하고, 다음 아이템을 얻는 작업을 합니다. 반면, Passive Iterator는 이 작업을 내부적으로 수행합니다. Java는 Iterator 패턴을 이용하여 Collection을 탐색합니다. Active에서 Passive한 형태로 발전했습니다. Enumeration초기 Java 1.0 때는 Collection에 Vector와 Hashtable만 있었고, Enumeration을 이용해 탐색하였습니다. Java 5 이후부터는 enum 타입과 헷갈리기 때문에 위 클래스들을 사용하지 않는 것이 좋습니다. Vector names = new Vector(); // ... add some names to the collection Enumeration e = names.elements(); while (e.hasMoreElements()) { String name = (String) e.nextElement(); System.out.println(name); } `&lt;/pre&gt; ## Iterator Java 1.2부터 Collections Framework를 설계하면서 Iterator라는 명확한 이름으로 구현되었습니다. &lt;pre&gt;`List names = new LinkedList(); // ... add some names to the collection Iterator i = names.iterator(); while (i.hasNext()) { String name = (String) i.next(); System.out.println(name); } `&lt;/pre&gt; ## Generics and the Enhanced for-loop Java 5부터는 Iteratable 인터페이스를 구현한 객체라면 for-each 구문을 이용할 수 있습니다. 기존에는 Active한 형태였지만 이제는 Passive한 형태로 진화하고 있는 과도기입니다. Java 7에서는 Diamond Operator를 이용해 타입 추론이 가능합니다. &lt;pre&gt;`List&lt;String&gt; names = new LinkedList&lt;String&gt;(); // Java 5 List&lt;String&gt; names = new LinkedList&lt;&gt;(); // Java 7 // ... add some names to the collection for (String name : names) System.out.println(name); `&lt;/pre&gt; ## forEach Java 8에서는 Iterable 인터페이스에 default 메소드로 forEach 메소드를 제공합니다. forEach 메소드의 인자로 lambda 표현식이 들어갑니다. 기존에는 ‘반복&apos;이라는 개념을 명시적으로 표현했다면, forEach는 이것을 암묵적으로 표현합니다. &lt;pre&gt;`List&lt;String&gt; names = new LinkedList&lt;&gt;(); // ... add some names to the collection names.forEach(name -&gt; System.out.println(name)); `&lt;/pre&gt; ## Stream API Java 8에서는 stream 메소드를 이용해 컬렉션을 다룰 수 있습니다. filter(), distinct(), sorted(), map() 등의 중간 연산과 count(), average(), sum(), max(), forEach() 등의 종단 연산을 연결할 수 있습니다. 각 아이템에 대한 연산을 병렬화 하려면 parallelStream() 메소드를 이용하면 됩니다. &lt;pre&gt;`List&lt;String&gt; names = new LinkedList&lt;&gt;(); // ... add some names to the collection long count = names.stream() .filter(name -&gt; name.startsWith(&quot;A&quot;)) .count(); PerformanceActive와 Passive 사이에는 큰 차이가 없습니다.LinkedList, LinkedHashSet은 stream과 parallelStream 사이에는 큰 차이가 없습니다.(순차 참조 자료 구조)ArrayList, TreeSet, HashSet은 parallelStream이 성능이 좋습니다.(직접 참조 자료 구조) ReferenceIterating over collections in Java 8","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Iterator","slug":"Iterator","permalink":"http://sarojaba.github.io/tags/Iterator/"}]},{"title":"최대-공약수와-최소-공배수","slug":"최대-공약수와-최소-공배수","date":"2015-01-06T15:48:00.000Z","updated":"2017-04-09T03:27:59.209Z","comments":true,"path":"2015/01/07/최대-공약수와-최소-공배수/","link":"","permalink":"http://sarojaba.github.io/2015/01/07/최대-공약수와-최소-공배수/","excerpt":"","text":"public class GCDLCM { public static void main(String[] args) { System.out.println(gcd(24, 18)); System.out.println(lcm(24, 18)); } public static int gcd(int a, int b) { int c = a % b; if (c == 0) { return b; } return gcd(b, c); } public static int lcm(int a, int b) { int m = a, n = b; int i = 1, j = 1; while (m != n) { if (m &lt; n) { m = a * ++i; } else { n = b * ++j; } } return m; } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"로마숫자","slug":"로마숫자","date":"2015-01-06T15:44:00.000Z","updated":"2017-04-09T03:28:15.772Z","comments":true,"path":"2015/01/07/로마숫자/","link":"","permalink":"http://sarojaba.github.io/2015/01/07/로마숫자/","excerpt":"","text":"public class RomaNum { private char[] signs = { &apos;I&apos;, &apos;V&apos;, &apos;X&apos;, &apos;L&apos;, &apos;C&apos;, &apos;D&apos;, &apos;M&apos; }; private int[] values = { 1, 5, 10, 50, 100, 500, 1000 }; public String toRomaNum(int digitNum) { StringBuilder sb = new StringBuilder(); String s = Integer.toString(digitNum); for (int i = 0; i &lt; s.length(); i++) { int d = s.length() - i - 1; char ch = s.charAt(i); switch (ch) { case &apos;1&apos;: sb.append(signs[d * 2]); break; case &apos;2&apos;: sb.append(signs[d * 2]); sb.append(signs[d * 2]); break; case &apos;3&apos;: sb.append(signs[d * 2]); sb.append(signs[d * 2]); sb.append(signs[d * 2]); break; case &apos;4&apos;: sb.append(signs[d * 2]); sb.append(signs[d * 2 + 1]); break; case &apos;5&apos;: sb.append(signs[d * 2 + 1]); break; case &apos;6&apos;: sb.append(signs[d * 2 + 1]); sb.append(signs[d * 2]); break; case &apos;7&apos;: sb.append(signs[d * 2 + 1]); sb.append(signs[d * 2]); sb.append(signs[d * 2]); case &apos;8&apos;: sb.append(signs[d * 2 + 1]); sb.append(signs[d * 2]); sb.append(signs[d * 2]); sb.append(signs[d * 2]); case &apos;9&apos;: sb.append(signs[d * 2]); sb.append(signs[d * 2 + 2]); break; default: break; } } return sb.toString(); } public int toDigitNum(String romaNum) { int[] n = new int[romaNum.length() * 3]; int sum = 0; for (int i = 0; i &lt; romaNum.length(); i++) { char sign = romaNum.charAt(i); for (int j = 0; j &lt; signs.length; j++) { if (sign == signs[j]) { n[i] = values[j]; break; } } } for (int i = 1; i &lt; n.length; i++) { if (n[i - 1] &lt; n[i]) { sum += n[i] - n[i - 1]; i++; } else { sum += n[i - 1]; } } return sum; } public static void main(String[] args) { RomaNum rn = new RomaNum(); System.out.println(rn.toRomaNum(2493)); System.out.println(rn.toDigitNum(&quot;MMMCCCXXXIII&quot;)); } } 예전 블로그에 있던 소스를 옮기고 있는데 지금 보니 무슨 생각으로 짰는지 모르겠다;; ㅎㄷㄷ","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"playn-game-loop","slug":"playn-game-loop","date":"2014-11-18T15:27:00.000Z","updated":"2017-04-09T03:28:33.308Z","comments":true,"path":"2014/11/19/playn-game-loop/","link":"","permalink":"http://sarojaba.github.io/2014/11/19/playn-game-loop/","excerpt":"","text":"PlayN은 게임의 메인 루프 진행을 위한 단순한 인터페이스를 제공한다. 이것은 플랫폼 간의 타이밍 구현의 복잡성을 분리하고, 논리적인 업데이트와 렌더링 업데이트의 분리를 추상화한다. 이 글은 PlayN의 구현과 게임의 메인 업데이트 사이클 예제를 설명한다. 게임 루프의 진행모든 PlayN 게임은 단순히 update와 paint 메소드를 포함한 Game 인터페이스를 구현한다. Game 인터페이스를 구현하고 PlayN.run(game)을 호출하면 다음 두 메소드를 영원히 호출하는 게임 루프를 통제하는 것을 포기해야 한다. while (true) { game.update(...); game.paint(...); } `&lt;/pre&gt; 물론 가능한 한 빠르게 동작하지는 않지만, 플랫폼이 실제로 프레임을 표시할 수 있는 정도로 제한된다. 프레임이 얼마나 빨리 표시 되는지는 갱신률이나, 플랫폼 특유의 최대 표시율에 따라 제한된다. 그러나 두 개의 특정 주기인 표시 주기와 갱신 주기를 고려해야 한다. 상대적으로 단순한 갱신 로직을 가진 게임은 다음과 같이 만들 수 있다. &lt;pre&gt;`public class MyGame implements Game { public void update(float delta) { // Update the game&apos;s state. // &apos;delta&apos; is the time in milliseconds since the last update call. } public void paint(float alpha) { // Paint using the game&apos;s current state. // &apos;alpha&apos; will always be zero. Ignore it. } public int updateRate() { // Returning zero here explicitly requests an update() call for each frame. return 0; } } 원문: https://developers.google.com/playn/devguide/gameloop","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"PlayN","slug":"PlayN","permalink":"http://sarojaba.github.io/tags/PlayN/"}]},{"title":"playn-개요","slug":"playn-개요","date":"2014-11-18T15:23:00.000Z","updated":"2017-04-09T03:28:51.271Z","comments":true,"path":"2014/11/19/playn-개요/","link":"","permalink":"http://sarojaba.github.io/2014/11/19/playn-개요/","excerpt":"","text":"최근 게임 개발 기술은 비약적으로 발전했다. 게임 개발자는 다양한 기술과 새로운 게임 플랫폼으로 개발하는 사람을 말한다. 게임 만들기는 쉬워지지 않았지만, 소셜, 모바일, 웹 기술의 발전이 많은 사람들이 게임을 하는 것을 쉽게 만들어줬다. 하지만 문제가 있다. 플랫폼이 너무 많다. 게임 개발자는 많은 사람들이 손안에서 게임하기를 원하지만 사용자는 통제되지 않는다. 그래서 게임을 각 플랫폼에 맞게 만들어야 하고, 시간 및 비용의 낭비, 유지보수의 어려움 등의 문제가 있다. 이런 이유로 PlayN이 태어났다. Modern game developers have to worry about many platforms. PlayN은 오픈소스 크로스 플랫폼 추상 레이어이다. GWT 컴파일러를 이용해 자바로 작성된 하나의 코드 베이스를 HTML5, Flash, Java, 안드로이드 어플로 컴파일한다. PlayN 아키텍처는 서비스-프로바이더 인터페이스 패턴을 사용하는데, 코어 부분은 코어 API 집합을 가지고 있고, 나머지 각 타겟에 구현이 분리되어 있다. PlayN을 사용하면 소스 코드에서 플랫폼 종속적인 호출은 제거되고, 하나의 코드 베이스에서 각 플랫폼 종속적인 구현의 결과물이 만들어진다. PlayN API service provider interface design PlayN은 게임 엔진이 아니다. 같은 게임을 여러 플랫폼으로 컴파일해주는 라이브러리이다. 많은 부분에서 각 플랫폼의 구현 코드만 가지고 있다. PlayN은 asset 툴체인, 애니메이션 효과, 추상 게임 로직 등을 가지고 있지 않다. PlayN의 목표는 update/render 루프, 유저 입력 처리, 리소스 관리 같이 일반적인 게임 오퍼레이션을 위한 크로스 컴파일 코드를 지원하는 기본 기술을 제공하는 것이다. 이는 핵심 라이브러리의 크기를 작게 유지하고, 특정 게임을 위한 코드 팽창을 피할 수 있다. 원문: https://developers.google.com/playn/overview","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"PlayN","slug":"PlayN","permalink":"http://sarojaba.github.io/tags/PlayN/"}]},{"title":"완전제곱수","slug":"완전제곱수","date":"2014-08-19T15:25:00.000Z","updated":"2017-04-09T03:29:12.739Z","comments":true,"path":"2014/08/20/완전제곱수/","link":"","permalink":"http://sarojaba.github.io/2014/08/20/완전제곱수/","excerpt":"","text":"public class SQR{ public static void main(String[] args){ sqr(60, 100); } public static void sqr(double min, double max){ int low = (int)Math.ceil(Math.sqrt(min)); int high = (int)Math.floor(Math.sqrt(max)); int sum = 0; for(int i = low; i &lt;= high; i++){ sum += i*i; } System.out.println(sum); System.out.println(low * low); } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"완전제곱수","slug":"완전제곱수","permalink":"http://sarojaba.github.io/tags/완전제곱수/"}]},{"title":"삽입-정렬","slug":"삽입-정렬","date":"2014-08-13T14:57:00.000Z","updated":"2017-04-09T03:29:29.642Z","comments":true,"path":"2014/08/13/삽입-정렬/","link":"","permalink":"http://sarojaba.github.io/2014/08/13/삽입-정렬/","excerpt":"","text":"삽입 정렬 public class InsertionSort{ public int[] insertionSort(int[] s){ int n = s.length; int val; // 임시 저장 공간 int j; for(int i = 1; i &lt; n; i++){ // 현재 위치의 요소를 임시로 저장 val = s[i]; j = i - 1; // 현재 위치 앞의 요소보다 작다면 서로 위치를 바꿈 while((j &gt;= 0) &amp;&amp; (val &lt; s[j])){ s[j + 1] = s[j]; j--; } s[j + 1] = val; } return s; } // 배열을 출력하는 메소드 public void display(int[] s){ for(int i = 0; i &lt; s.length; i++){ System.out.print(s[i] + &quot; &quot;); } System.out.println(); } public static void main(String[] args){ InsertionSort s = new InsertionSort(); s.display(s.insertionSort(new int[]{8, 13, 20, 27, 16})); } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"개미-수열","slug":"개미-수열","date":"2014-08-13T14:53:00.000Z","updated":"2017-04-09T03:29:45.706Z","comments":true,"path":"2014/08/13/개미-수열/","link":"","permalink":"http://sarojaba.github.io/2014/08/13/개미-수열/","excerpt":"","text":"개미 수열 public class Ant{ public static int[] array1; public static int[] array2; public static void main(String[] args){ int length = Integer.parseInt(args[0]); array1 = new int[50]; array1[0] = 1; for(int i = 0; i &lt; length; i++){ for(int j = 0; j &lt; array1.length; j++){ if(array1[j] != 0){ System.out.print(array1[j]+&quot; &quot;); } } array1 = makeNextLine(array1); System.out.println(); } } public static int[] makeNextLine(int[] array1){ int[] array2 = new int[50]; array2[0] = array1[0]; int index = 1; int count = 1; for(int i = 1; i &lt; array1.length; i++){ if(array1[i-1] == array1[i]){ count++; }else{ array2[index] = count; index++; array2[index] = array1[i]; index++; count = 1; } } return array2; } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"피보나치-수열","slug":"피보나치-수열","date":"2014-07-31T15:08:00.000Z","updated":"2017-04-09T03:30:00.338Z","comments":true,"path":"2014/08/01/피보나치-수열/","link":"","permalink":"http://sarojaba.github.io/2014/08/01/피보나치-수열/","excerpt":"","text":"피보나치 수열 public class Fibonacci{ // 피보나치 수열을 출력하는 메소드 public void fibonacciSequence(int n){ // n은 수열의 길이 for(int i = 0; i &lt; n; i++){ System.out.print(getFibonacciNum(i + 1) + &quot; &quot;); } System.out.println(); } // 인자로 받은 위치의 피보나치 수를 반환하는 메소드 private int getFibonacciNum(int i){ if(i == 1){ return 1; // 첫번째 요소이면 1 }else if(i == 2){ return 2; // 두번째 요소이면 2 } // 현재의 수는 앞의 수와 그 앞의 수의 합 return getFibonacciNum(i - 1) + getFibonacciNum(i - 2); } public static void main(String[] args){ Fibonacci f = new Fibonacci(); f.fibonacciSequence(10); } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Fibonacci Number","slug":"Fibonacci-Number","permalink":"http://sarojaba.github.io/tags/Fibonacci-Number/"}]},{"title":"coffeescript-game-tutorial-the-mouse","slug":"coffeescript-game-tutorial-the-mouse","date":"2014-07-31T15:01:00.000Z","updated":"2017-04-09T03:31:28.587Z","comments":true,"path":"2014/08/01/coffeescript-game-tutorial-the-mouse/","link":"","permalink":"http://sarojaba.github.io/2014/08/01/coffeescript-game-tutorial-the-mouse/","excerpt":"","text":"마우스 이벤트 처리 코드를 추가하였다. ###coffee init_mouse = -&gt; canvasMinX = 0 canvasMaxX = canvasMinX + WIDTH document.onmousemove = (evt) -&gt; if evt.pageX &gt; canvasMinX and evt.pageX &lt; canvasMaxX paddlex = evt.pageX - canvasMinX draw = -&gt; clear() circle(x, y, 10) # move the paddle if left or right is currently pressed paddlex += 5 if rightDown paddlex -= 5 if leftDown rect(paddlex, HEIGHT-paddleh, paddlew, paddleh) dx = -dx if x + dx &gt; WIDTH or x + dx &lt; 0 if y + dy &lt; 0 then dy = -dy else if y + dy &gt; HEIGHT if x &gt; paddlex and x &lt; paddlex + paddlew dy = -dy else # game over, so stop the animation clearInterval(intervalId) x += dx; y += dy; window.onload = -&gt; init() init_mouse() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"}]},{"title":"coffeescript-game-tutorial-the-keyboard","slug":"coffeescript-game-tutorial-the-keyboard","date":"2014-07-29T14:30:00.000Z","updated":"2017-04-09T03:32:38.758Z","comments":true,"path":"2014/07/29/coffeescript-game-tutorial-the-keyboard/","link":"","permalink":"http://sarojaba.github.io/2014/07/29/coffeescript-game-tutorial-the-keyboard/","excerpt":"","text":"키보드 이벤트를 추가한 코드이다. ###coffee rightDown = false leftDown = false # set rightDown or leftDown if the right or left key are down document.onkeydown = (evt) -&gt; switch evt.keyCode when 39 then rightDown = true when 37 then leftDown = true # and unset then when the right or left key is released document.onkeyup = (evt) -&gt; switch evt.keyCode when 39 then rightDown = false when 37 then leftDown = false draw = -&gt; clear() circle(x, y, 10) # move the paddle if left or right is currently pressed paddlex += 5 if rightDown paddlex -= 5 if leftDown rect(paddlex, HEIGHT-paddleh, paddlew, paddleh) dx = -dx if x + dx &gt; WIDTH or x + dx &lt; 0 if y + dy &lt; 0 then dy = -dy else if y + dy &gt; HEIGHT if x &gt; paddlex and x &lt; paddlex + paddlew dy = -dy else # game over, so stop the animation clearInterval(intervalId) x += dx; y += dy; window.onload = -&gt; init() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"CoffeScript","slug":"CoffeScript","permalink":"http://sarojaba.github.io/tags/CoffeScript/"}]},{"title":"coffeescript-game-tutorial-add-a-paddle","slug":"coffeescript-game-tutorial-add-a-paddle","date":"2014-07-29T14:27:00.000Z","updated":"2017-04-09T03:33:42.144Z","comments":true,"path":"2014/07/29/coffeescript-game-tutorial-add-a-paddle/","link":"","permalink":"http://sarojaba.github.io/2014/07/29/coffeescript-game-tutorial-add-a-paddle/","excerpt":"","text":"화면 하단에 막대기를 추가한 코드이다. ###coffee paddlex = 0 paddleh = 0 paddlew = 0 init_paddle = -&gt; paddlex = WIDTH / 2 paddleh = 10 paddlew = 75 draw = -&gt; clear() circle(x, y, 10) rect(paddlex, HEIGHT - paddleh, paddlew, paddleh) dx = -dx if x + dx &gt; WIDTH or x + dx &lt; 0 if y + dy &lt; 0 dy = -dy else if y + dy &gt; HEIGHT if x &gt; paddlex and x &lt; paddlex + paddlew dy = -dy else clearInterval(intervalId) x += dx; y += dy; window.onload = -&gt; init() init_paddle() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"}]},{"title":"coffeescript-game-tutorial-bounce","slug":"coffeescript-game-tutorial-bounce","date":"2014-07-28T18:45:00.000Z","updated":"2017-04-09T03:34:20.340Z","comments":true,"path":"2014/07/29/coffeescript-game-tutorial-bounce/","link":"","permalink":"http://sarojaba.github.io/2014/07/29/coffeescript-game-tutorial-bounce/","excerpt":"","text":"공 튀기는 코드이다. ###coffee ### BEGIN LIBRARY CODE ### x = 150 y = 150 dx = 2 dy = 4 ctx = null WIDTH = 0 HEIGHT = 0 init = -&gt; canvas = document.getElementById(&quot;myCanvas&quot;) ctx = canvas.getContext(&quot;2d&quot;) WIDTH = canvas.width HEIGHT = canvas.height setInterval(draw, 10) circle = (x, y, r) -&gt; ctx.beginPath() ctx.arc(x, y, r, 0, Math.PI*2, true) ctx.closePath() ctx.fill() rect = (x, y, w, h) -&gt; ctx.beginPath() ctx.rect(x, y, w, h) ctx.closePath() ctx.fill() clear = -&gt; ctx.clearRect(0, 0, WIDTH, HEIGHT) ### END LIBRARY CODE ### draw = -&gt; clear() circle(x, y, 10) dx = -dx if x + dx &gt; WIDTH or x + dx &lt; 0 dy = -dy if y + dy &gt; HEIGHT or y + dy &lt; 0 x += dx; y += dy; window.onload = -&gt; init() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"CoffeScript","slug":"CoffeScript","permalink":"http://sarojaba.github.io/tags/CoffeScript/"}]},{"title":"coffeescript-game-tutorial-libary-an-interlude","slug":"coffeescript-game-tutorial-libary-an-interlude","date":"2014-07-27T16:31:00.000Z","updated":"2017-04-09T03:34:34.272Z","comments":true,"path":"2014/07/28/coffeescript-game-tutorial-libary-an-interlude/","link":"","permalink":"http://sarojaba.github.io/2014/07/28/coffeescript-game-tutorial-libary-an-interlude/","excerpt":"","text":"지금까지 했던걸 라이브러리 형태로 정리한 코드이다. # BEGIN LIBRARY CODE x = 150 y = 150 dx = 2 dy = 4 WIDTH = 0 HEIGHT = 0 ctx = null init = -&gt; canvas = document.getElementById(&quot;myCanvas&quot;) ctx = canvas.getContext(&quot;2d&quot;) WIDTH = canvas.width HEIGHT = canvas.height intervalId = setInterval(draw, 10) circle = (x, y, r) -&gt; ctx.beginPath() ctx.arc(x, y, r, 0, Math.PI*2, true) ctx.closePath() ctx.fill() rect = (x, y, w, h) -&gt; ctx.beginPath() ctx.rect(x, y, w, h) ctx.closePath() ctx.fill() clear = -&gt; ctx.clearRect(0, 0, WIDTH, HEIGHT) # END LIBRARY CODE draw = -&gt; clear() circle(x, y, 10) x += dx; y += dy; window.onload = -&gt; init() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"}]},{"title":"coffeescript-game-tutorial-action","slug":"coffeescript-game-tutorial-action","date":"2014-06-26T15:58:00.000Z","updated":"2017-04-09T03:34:48.287Z","comments":true,"path":"2014/06/27/coffeescript-game-tutorial-action/","link":"","permalink":"http://sarojaba.github.io/2014/06/27/coffeescript-game-tutorial-action/","excerpt":"","text":"원이 대각선 아래로 움직이는 코드이다. x = 150 y = 150 dx = 2 dy = 4 ctx = null init = -&gt; canvas = document.getElementById(&quot;myCanvas&quot;) ctx = canvas.getContext(&quot;2d&quot;) return setInterval(draw, 10) draw = -&gt; ctx.clearRect(0, 0, 300, 300) ctx.beginPath() ctx.arc(x, y, 10, 0, Math.PI*2, true) ctx.closePath() ctx.fill() x += dx; y += dy; window.onload = -&gt; init() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://sarojaba.github.io/tags/Canvas/"}]},{"title":"coffeescript-game-tutorial-add-some-color","slug":"coffeescript-game-tutorial-add-some-color","date":"2014-06-26T15:54:00.000Z","updated":"2017-04-09T03:35:05.170Z","comments":true,"path":"2014/06/27/coffeescript-game-tutorial-add-some-color/","link":"","permalink":"http://sarojaba.github.io/2014/06/27/coffeescript-game-tutorial-add-some-color/","excerpt":"","text":"색깔 원을 그리는 코드이다. window.onload = -&gt; # get a reference to the canvas canvas = document.getElementById(&quot;canvas&quot;) ctx = canvas.getContext(&quot;2d&quot;) ctx.fillStyle = &quot;#00A308&quot; ctx.beginPath() ctx.arc(220, 220, 50, 0, Math.PI*2, true) ctx.closePath() ctx.fill() ctx.fillStyle = &quot;#FF1C0A&quot; ctx.beginPath() ctx.arc(100, 100, 100, 0, Math.PI*2, true) ctx.closePath() ctx.fill() # the rectangle is half transparent ctx.fillStyle = &quot;rgba(255, 255, 0, 0.5)&quot; ctx.beginPath() ctx.rect(15, 150, 120, 120) ctx.closePath() ctx.fill() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://sarojaba.github.io/tags/Canvas/"}]},{"title":"coffeescript-game-tutorial-draw-a-circle","slug":"coffeescript-game-tutorial-draw-a-circle","date":"2014-06-26T15:52:00.000Z","updated":"2017-04-09T03:35:17.240Z","comments":true,"path":"2014/06/27/coffeescript-game-tutorial-draw-a-circle/","link":"","permalink":"http://sarojaba.github.io/2014/06/27/coffeescript-game-tutorial-draw-a-circle/","excerpt":"","text":"캔버스에 동그라미를 그리는 코드이다. window.onload = -&gt; # get a reference to the canvas canvas = document.getElementById(&quot;canvas&quot;) ctx = canvas.getContext(&quot;2d&quot;) # draw a circle ctx.beginPath() ctx.arc(75, 75, 10, 0, Math.PI * 2, true) ctx.closePath() ctx.fill() Reference","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"},{"name":"Canvas","slug":"Canvas","permalink":"http://sarojaba.github.io/tags/Canvas/"}]},{"title":"coffeescript-game-tutorial-introduction","slug":"coffeescript-game-tutorial-introduction","date":"2014-06-26T15:49:00.000Z","updated":"2017-04-09T03:35:32.566Z","comments":true,"path":"2014/06/27/coffeescript-game-tutorial-introduction/","link":"","permalink":"http://sarojaba.github.io/2014/06/27/coffeescript-game-tutorial-introduction/","excerpt":"","text":"HTML5의 Canvas를 이용해 게임을 만들어보자. 하지만 커피 스크립트라는 언어의 매력에 빠져 자바 스크립트 공부는 바이바이~ 해버렸다. 자바 스크립트만큼 공부할 자료가 많지는 않지만 언어가 워낙 간결하다보니 조금씩 해보면 금방 익힐&hellip; 수 있을까? ㅋㅋ 자자 서론이 너무 길다. 난 글 적는거 싫어하므로 냅다 소스코드만 보여줄거다. 보고 공부할 자료는 http://billmill.org/static/canvastutorial/ 의 자바 스크립트로 게임을 만드는 튜토리얼이다. 이 내용을 커피 스크립트로 코딩할거니 알아서 비교해서 보기 바란다;; 다음 글부터 시작이다. 고고고~","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"}]},{"title":"basic-audio","slug":"basic-audio","date":"2014-06-24T17:08:00.000Z","updated":"2017-04-09T03:36:26.771Z","comments":true,"path":"2014/06/25/basic-audio/","link":"","permalink":"http://sarojaba.github.io/2014/06/25/basic-audio/","excerpt":"","text":"튜토리얼 보면서 따라한 코드이다.배경음악은 주구장창 흘러나오고, 마우스나 손가락으로 터치할때마다 효과음이 발생한다. package com.awesome; import com.badlogic.gdx.ApplicationListener; import com.badlogic.gdx.Gdx; import com.badlogic.gdx.audio.Music; import com.badlogic.gdx.audio.Sound; import com.badlogic.gdx.files.FileHandle; public class SuperAwesomeExample implements ApplicationListener { Music music; Sound sound; @Override public void create() { FileHandle musicFile = Gdx.files.internal(&quot;data/Kalimba.mp3&quot;); music = Gdx.audio.newMusic(musicFile); FileHandle soundFile = Gdx.files.internal(&quot;data/MediumExplosion8-Bit.ogg&quot;); sound = Gdx.audio.newSound(soundFile); music.setLooping(true); music.setVolume(0.5f); music.play(); } @Override public void render() { if(Gdx.input.justTouched()) { sound.play(); } } @Override public void resize(int arg0, int arg1) { // TODO Auto-generated method stub } @Override public void pause() { // TODO Auto-generated method stub } @Override public void resume() { // TODO Auto-generated method stub } @Override public void dispose() { music.dispose(); sound.dispose(); } } p.s) 어제 스킨을 변경했더니 SyntaxHighlighter 코드가 날아갔네 ㄷㄷ","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"http://sarojaba.github.io/tags/Android/"},{"name":"LibGDX","slug":"LibGDX","permalink":"http://sarojaba.github.io/tags/LibGDX/"}]},{"title":"basic-file-io","slug":"basic-file-io","date":"2014-06-24T17:04:00.000Z","updated":"2017-04-09T03:37:52.159Z","comments":true,"path":"2014/06/25/basic-file-io/","link":"","permalink":"http://sarojaba.github.io/2014/06/25/basic-file-io/","excerpt":"","text":"File IO 방법은 간단하다. 네가지 모드가 있지만 우선 자주 쓰는건 두가지 인듯.internal은 해당 프로젝트의 디렉토리를 기준으로 한다.(안드로이드의 경우 asset)external은 home 디렉토리를 기준으로 한다.(안드로이드의 경우 sdcard) FileHandle file = Gdx.files.internal(&quot;data/test.txt&quot;); String txt = file.readString(); 위와 같이 텍스트 파일을 처리할 수 있다. p.s) 공부하면서 쓰는 내용이라 체계적으로 정리가 안되네.시간나면 좀 더 고쳐봐야겠다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"http://sarojaba.github.io/tags/Android/"},{"name":"LibGDX","slug":"LibGDX","permalink":"http://sarojaba.github.io/tags/LibGDX/"}]},{"title":"application-lifecycle-살펴보기","slug":"application-lifecycle-살펴보기","date":"2014-06-23T16:13:00.000Z","updated":"2017-04-09T03:38:24.622Z","comments":true,"path":"2014/06/24/application-lifecycle-살펴보기/","link":"","permalink":"http://sarojaba.github.io/2014/06/24/application-lifecycle-살펴보기/","excerpt":"","text":"갑자기 만들고 싶은 게임이 생겼습니다. 취미로 간단히 만들거라 시간 단축이 필요했습니다.안드로이드에서 돌아가는 게임 개발 프레임워크를 구글링 해보았습니다.첫 페이지에서 눈에 띄는 것은 rokon 과 AndEngine.rokon 페이지에 들어가니 개발이 종료되었다는 내용을 발견했습니다. 대신 rokon 개발자가 libgdx 라는 프레임워크를 추천해 놓았습니다. AndEngine은 배우기 쉽다는 내용도 있었습니다.libgdx 프레임워크를 찾아들어가니 현재도 왕성한 오픈소스 활동을 하고 있었습니다.무엇보다 다양한 플랫폼(윈도우, 리눅스, 맥, 안드로이드 등)을 지원한다는 것이 선택의 가장 큰 이유가 되었습니다. 튜토리얼을 보기 전에 어플리케이션 라이프 사이클을 살펴보았습니다.애플릿의 라이프 사이클과 비슷했기에 거리감은 없었습니다. 코드로 보면 다음과 같습니다. ApplicationListener를 implements 하여 main에서 호출합니다. main에서 LwjglApplication 클래스는 JoglApplication 클래스로 변경하여 생성하여도 됩니다. public class MyGame implements ApplicationListener { public void create () { // STUB } public void render () { // STUB } public void resize (int width, int height) { // STUB } public void pause () { // STUB } public void resume () { // STUB } public void dispose () { // STUB } } import com.badlogic.gdx.backends.lwjgl.LwjglApplication; public class MyDesktopGame { public static void main(String[] args) { new LwjglApplication(new MyGame(), &quot;My Game&quot;, 480, 320, false); } }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Android","slug":"Android","permalink":"http://sarojaba.github.io/tags/Android/"},{"name":"LibGDX","slug":"LibGDX","permalink":"http://sarojaba.github.io/tags/LibGDX/"}]},{"title":"serializationutils-클래스-살펴보기","slug":"serializationutils-클래스-살펴보기","date":"2014-06-04T13:17:00.000Z","updated":"2017-04-09T03:38:56.266Z","comments":true,"path":"2014/06/04/serializationutils-클래스-살펴보기/","link":"","permalink":"http://sarojaba.github.io/2014/06/04/serializationutils-클래스-살펴보기/","excerpt":"","text":"Apache Commons Lang 컴포넌트의 SerializationUtils 클래스의 clone 메소드에 대해 살펴보자. clone 메소드를 이용하기 위해선 Serializable 인터페이스를 구현해줘야한다. 기존의 Object 클래스의 clone 메소드를 오버라이드 한 예제이다. public class Main { public static void main(String[] args) { try { 붕어빵 a = new 붕어빵(); 붕어빵 b = (붕어빵) a.clone(); System.out.println(a.price); System.out.println(b.price); } catch (CloneNotSupportedException e) { e.printStackTrace(); } } } class 붕어빵 implements Cloneable { public int price = 200; @Override protected Object clone() throws CloneNotSupportedException { 붕어빵 obj = (붕어빵) super.clone(); obj.price = price; return obj; } } `&lt;/pre&gt; SerializtionUtils 클래스의 clone 메소드를 이용한 예제이다. &lt;pre&gt;`###java import java.io.Serializable; import org.apache.commons.lang3.SerializationUtils; public class Main { public static void main(String[] args) { 붕어빵 a = new 붕어빵(); 붕어빵 b = SerializationUtils.clone(a); System.out.println(a.price); System.out.println(b.price); } } class 붕어빵 implements Serializable { public int price = 200; } 우와~ 이 얼마나 단순한가;; 난 이런거 좋아 ㅎㅎ","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Apache Commons","slug":"Apache-Commons","permalink":"http://sarojaba.github.io/tags/Apache-Commons/"}]},{"title":"wordutils-클래스-살펴보기","slug":"wordutils-클래스-살펴보기","date":"2014-06-04T12:43:00.000Z","updated":"2017-04-09T03:39:14.213Z","comments":true,"path":"2014/06/04/wordutils-클래스-살펴보기/","link":"","permalink":"http://sarojaba.github.io/2014/06/04/wordutils-클래스-살펴보기/","excerpt":"","text":"Apache Commons Lang 컴포넌트의 WordUtils 클래스에 대해 알아보자.말그대로 단어를 쉽게 다룰 수 있는 기능을 제공한다. import org.apache.commons.lang3.text.WordUtils; public class Main { public static void main(String[] args) { // capitalize 메소드는 단어의 첫 글자를 대문자로 치환한다. System.out.println(WordUtils.capitalize(&quot;hello world!&quot;)); // initials 메소드는 단어들의 이니셜을 구한다. // 즉, 각 단어들의 첫글자만 남긴다. System.out.println(WordUtils.initials(&quot;Java development Kit&quot;)); // wrap 메소드는 텍스트 편집기의 워드랩 기능을 제공한다. // 즉, 단어별로 한 라인의 남은 칸에 다 적히지 않으면 해당 단어를 다음 라인에 적는다. System.out.println(WordUtils.wrap(&quot;Hello world!&quot;, 8 )); System.out.println(WordUtils.wrap(&quot;Hello world!&quot;, 12)); } } `&lt;/pre&gt; 결과이다. &lt;pre&gt;`Hello World! JdK Hello world! Hello world!","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Apache Commons","slug":"Apache-Commons","permalink":"http://sarojaba.github.io/tags/Apache-Commons/"}]},{"title":"stringutils-클래스-이해하기","slug":"stringutils-클래스-이해하기","date":"2014-06-02T16:27:00.000Z","updated":"2017-04-09T03:39:31.645Z","comments":true,"path":"2014/06/03/stringutils-클래스-이해하기/","link":"","permalink":"http://sarojaba.github.io/2014/06/03/stringutils-클래스-이해하기/","excerpt":"","text":"이번 시간에는 Apache Commons Lang 컴포넌트의 StringUtils 클래스에 대해 살펴보겠다. StringUtils 클래스는 말 그대로 문자열을 손쉽게 다룰 수 있도록 도우미 메소드를 모아놓은 클래스이다. 또 하나 유용한 것은 null에 안전하다는 것이다. 좀 유용하다 싶은 것들로 예제를 작성해보았다. import org.apache.commons.lang3.StringUtils; public class Main { public static void main(String[] args) { // abbreviate 메소드는 문장을 축약하는 기능을 제공한다. // 게시판 제목을 줄일 때 사용하면 좋을 듯 하다. System.out.println(StringUtils.abbreviate(&quot;Hello world!&quot;, 5)); System.out.println(StringUtils.abbreviate(&quot;Hello&quot;, 5)); // capitalize 메소드는 문장의 첫 글자를 대문자로 만드는 기능을 제공한다. // 워드 프로세서에서 자주 사용되는 기능이다. System.out.println(StringUtils.capitalize(&quot;hello world!&quot;)); // center 메소드는 문장을 가운데 정렬하는 기능을 제공한다. System.out.println(StringUtils.center(&quot;Hello world!&quot;, 20)); System.out.println(StringUtils.center(&quot;Hello world!&quot;, 20, &apos;*&apos;)); // containsAny 메소드는 해당 문장에 포함된 문자나 문자열이 있는지 판단한다. // 예제처럼 가변인자로도 받을 수 있다. System.out.println(StringUtils.containsAny(&quot;Hello world!&quot;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;)); System.out.println(StringUtils.containsAny(&quot;Hello world!&quot;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;)); // join 메소드는 각 문자열 사이에 문자나 문자열을 집어넣는 기능을 제공한다. // 예제로 전화번호 사이의 하이픈을 넣어보았다. System.out.println(StringUtils.join(new String[] { &quot;010&quot;, &quot;1234&quot;, &quot;4567&quot; }, &apos;-&apos;)); // repeat 메소드는 해당 문자열을 반복해주는 기능을 제공한다. // 패스워드가 저장된 이후 접속 시 사용하면 유용할 듯하다. System.out.println(StringUtils.repeat(&apos;*&apos;, 5)); } } `&lt;/pre&gt; 실행 결과이다. &lt;pre&gt;`He... Hello Hello world! Hello world! ****Hello world!**** true false 010-1234-4567 이 밖에도 다양한 기능들이 있지만 너무 많기도 많고 메소드들이 너무 직관적이라 구지 더 설명할 필요가 없을 듯하다. 다른 메소드들도 사용해보기 바란다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Apache Commons","slug":"Apache-Commons","permalink":"http://sarojaba.github.io/tags/Apache-Commons/"}]},{"title":"coffeescript-이해하기","slug":"coffeescript-이해하기","date":"2014-06-01T14:41:00.000Z","updated":"2017-04-09T03:39:48.729Z","comments":true,"path":"2014/06/01/coffeescript-이해하기/","link":"","permalink":"http://sarojaba.github.io/2014/06/01/coffeescript-이해하기/","excerpt":"","text":"CoffeeScript는 JavaScript로 컴파일되는 미니 언어이다. 나는 JavaScript를 잘 다루지 못하지만 웹으로 재미난 것들을 만들고 싶은 마음이 많이 들어 대안책으로 CoffeeScript를 선택해보았다. 간결한 문법, JavaScript와 완벽하게 매칭된다는 점, REPL을 지원한다는 점등이 매력적인 요소로 다가왔다. JavaScript의 역사에 대해 정리해놓은 발표 자료이다. 복잡해지고 있는 JavaScript의 대안책으로 손색없이 보인다. JavaScript History View more presentations from Kim Rhio 자세한 설명은 http://coffeescript.org/ 에서 볼 수 있다. 글쓰기도 귀찮고 좀 더 살펴보고 뭔가 해보아야겠다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"CoffeeScript","slug":"CoffeeScript","permalink":"http://sarojaba.github.io/tags/CoffeeScript/"}]},{"title":"c-알고리즘-수행시간-측정하기","slug":"c-알고리즘-수행시간-측정하기","date":"2014-06-01T14:36:00.000Z","updated":"2017-04-09T03:40:18.192Z","comments":true,"path":"2014/06/01/c-알고리즘-수행시간-측정하기/","link":"","permalink":"http://sarojaba.github.io/2014/06/01/c-알고리즘-수행시간-측정하기/","excerpt":"","text":"마이크로 초 단위로 측정하기 #include &lt;sys/time.h&gt; struct timeval start, end; long elapsed; gettimeofday(&amp;start, NULL); // 알고리즘 gettimeofday(&amp;end, NULL); elapsed = end.tv_usec - start.tv_usec; printf(&quot;%ld\\n&quot;, elapsed);","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"C","slug":"C","permalink":"http://sarojaba.github.io/tags/C/"}]},{"title":"eclipse-rcp-tutorial14","slug":"eclipse-rcp-tutorial14","date":"2014-06-01T01:57:00.000Z","updated":"2017-04-09T03:42:19.553Z","comments":true,"path":"2014/06/01/eclipse-rcp-tutorial14/","link":"","permalink":"http://sarojaba.github.io/2014/06/01/eclipse-rcp-tutorial14/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 제품 배포하기제품 설정은 독립형 RCP 어플리케이션을 생성하는데 사용된다. 제품을 추출하고 다른 사용자들과 결과를 공유할 수 있다. 이클립스는 자동적으로 빌드 경로로 컴파일된 클래스를 포함한다. 다른 파일들은 수동으로 관리해야한다. 만약 아이콘이나 스플래시 화면 이미지 등을 사용한다면 빌드 경로에 추가해줘야 한다. 빌드에 포함된 것은 &ldquo;plugin.xml&rdquo; 파일을 통해 정의된다. &lsquo;plugin.xml&quot; 을 선택하고 &ldquo;Build&rdquo; 탭을 선택한다. &ldquo;META-INF&rdquo; 디렉토리와 &ldquo;plugin.xml&rdquo; 파일, 그리고 아이콘, splash.bmp 와 같은 다른 정적 파일들은 출력에 포함되어야 한다. 제품 설정 파일로 변경하고 &ldquo;Overview&rdquo; 탭을 선택한다. 제품을 추출하기 위해 &ldquo;Eclipse Product export wizard&rdquo; 를 클릭한다. 목표 디렉토리를 기입하고 &ldquo;Finish&rdquo; 를 누른다. 특정 장소에 애플리케이션을 실행하는 &ldquo;eclipse.exe&rdquo; 파일을 포함하는 &ldquo;eclipse&rdquo; 디렉토리를 생성할 것이다. 애플리케이션을 실행하기위해 더블 클릭한다. 다른 기계(자바가 설치되어 있는)에서 이 디렉토리의 내용을 얻거나 압축을 푼다면 프로그램은 거기서도 동작해야 한다. 추출 대화창은 당신의 사용자에게 직접 전송할 수 있는 아카이브 파일을 생성한다. 제품 생성을 자동화하는 방법은 Eclipse PDE Build 를 참고하라. 팁과 트릭사용자 레이아웃을 저장하기애플리케이션의 다음 실행을 위해 사용자 레이아웃과 윈도우 크기를 저장하려면 ApplicationWorkbenchAdvisor 의 초기화 메소드에 configurer.setSaveAndRestore(true); 를 추가한다. package addactiontoview; import org.eclipse.ui.application.IWorkbenchConfigurer; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchAdvisor; import org.eclipse.ui.application.WorkbenchWindowAdvisor; public class ApplicationWorkbenchAdvisor extends WorkbenchAdvisor { private static final String PERSPECTIVE_ID = &quot;AddActiontoView.perspective&quot;; public WorkbenchWindowAdvisor createWorkbenchWindowAdvisor( IWorkbenchWindowConfigurer configurer) { return new ApplicationWorkbenchWindowAdvisor(configurer); } public String getInitialWindowPerspectiveId() { return PERSPECTIVE_ID; } @Override public void initialize(IWorkbenchConfigurer configurer) { super.initialize(configurer); configurer.setSaveAndRestore(true); } } 이클립스는 퍼스펙티브를 리셋하기 위한 미리 정의된 명령을 가진다. Eclipse Commands 를 참고하라. 사용하지 않는 종속성 찾기&ldquo;plugin.xml&rdquo; 파일의 &ldquo;Dependencies&rdquo; 탭에서 어느 플러그인에 당신의 플러그인이 종속적인지 정의한다. 물론 단지 필요한 플러그인만 여기 정의해야 한다. 어떤 종속성이라도 가지고 있다면 Dependency Analysis -&gt; Find unused dependencies 를 선택하여 실제로 사용하지 않는 것을 검사할 수 있다. RCP 애플리케이션을 자신의 JRE 와 함께 배포하기특정 JRE 가 사용됨을 보장하기 위해 자신의 RCP 애플리케이션과 함께 배포할 수 있다. 이클립스 RCP 애플리케이션은 가장 먼저 설치 디렉토리에 &ldquo;jre&rdquo; 폴더가 있는지 자바 가상머신이 있는지 검사한다. 만약 발견되면 그 JRE 는 이클립스 RCP 애플리케이션에 사용된다. 다수의 사용자 설정하기이클립스 RCP 애플리케이션은 설정 파일들을 &ldquo;.metadata&rdquo; 폴더에 저장한다. 표준 설정에 있는 이클립스 RCP 설치 디렉토리는 이 폴더를 위해 사용될 것이다. 만약 둘 이상의 사용자가 같은 설치 폴더를 사용한다면, 대안의 장소를 명시하기 위해 &ldquo;-data&rdquo; 인자를 제공해야 한다. &ldquo;@user.home/applicationname&rdquo; 값을 설정했다면 설정은 사용자가 명시한 폴더에 저장될 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial13","slug":"eclipse-rcp-tutorial13","date":"2014-06-01T01:54:00.000Z","updated":"2017-04-09T03:42:38.869Z","comments":true,"path":"2014/06/01/eclipse-rcp-tutorial13/","link":"","permalink":"http://sarojaba.github.io/2014/06/01/eclipse-rcp-tutorial13/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 제품과 브랜딩지금까지는 RCP 어플리케이션을 이클립스에서만 실행할 수 있다. 다음 챕터에서 이클립스 IDE 외부에서 실행할 수 있는 프로그램으로 추출하는데 사용되는 제품 설정을 생성할 것이다. 어플리케이션 VS 제품이클립스 RCP 에서 자바 main() 메소드의 같은 점은 &ldquo;application&rdquo; 이다. 애플리케이션은 &ldquo;org.eclipse.core.runtime.applications&rdquo; 확장점을 통해 정의된다. 다수의 애플리케이션을 정의할 수 있지만 한번에 하나만 실행할 수 있다. 또한 이클립스는 어플리케이션에 필요한 모든 자원(아이콘, 스플래시 이미지, 외부 jar, 그외 플러그인 등등)을 정의하는 &ldquo;product&rdquo; 를 정의한다. 제품은 어플리케이션의 내용을 기술하는 개발 인공 산물이고 구동시 필요하지 않다. 제품 설정제품을 생성하기 위해서는 제품 설정이 필요하다. 이 설정 파일은 필요한 패키지들, 설정 파일 등에 대한 모든 정보를 가지고 있다. 설정 파일은 제품을 추출하고 생성하는데 사용된다. 제품 설정을 생성하기&ldquo;RCP application with a view&rdquo; 템플릿 기반의 새로운 프로젝트 &ldquo;de.vogella.rcp.intro.deploy&rdquo; 를 생성한다. 작동되는지 검사하기 위해 실행한다. 프로젝트에 오른쪽 클릭을 하고 New -&gt; Product Configuration 을 선택한다. 제품 설정을 &ldquo;de.vogella.rcp.intro.deploy.product&rdquo; 라고 이름 짓는다. &ldquo;Create a configuration file with basis settings&rdquo; 를 선택한다. &ldquo;Finish&rdquo; 를 누른다. &ldquo;de.vogella.rcp.intro.deploy.product&rdquo; 파일을 열고 &ldquo;Overview&rdquo; 탭을 선택한다. id 는 &ldquo;de.vogella.rcp.intro.deploy.product&rdquo;, 이름은 &ldquo;DeployTest&rdquo; 를 적는다. 이름은 윈도우의 제목에 보여질 것이다. &ldquo;Product Definition&rdquo; 부분의 &ldquo;New&rdquo; 를 누르고 &ldquo;de.vogella.rcp.intro.deploy.application&rdquo; 플러그인의 어플리케이션을 선택한다. 결과로 &ldquo;Product Definition&rdquo; 부분이 채워질 것이다. 제품 식별자는 &ldquo;plugin.xml&rdquo; 파일의 &ldquo;org.eclipse.core.runtime.product&rdquo; 확장으로서 저장된다. 종속성제품은 플러그인이나 특징을 기반으로 한다. 이 설정은 개요 탭에서 완성된다. 플러그인에 기반한 제품 정의를 사용할 것이다. 특징 프로젝트를 생성하는 자세한 방법은 이클립스 특징 프로젝트 - 튜토리얼 을 참고하세요. &ldquo;Dependencies&rdquo; 탭으로 옮기고 &ldquo;Add&rdquo; 를 클릭한다. &ldquo;de.vogella.rcp.intro.deploy&rdquo; 플러그인을 선택한다. &ldquo;Add Required Plug-ins&rdquo; 을 누르고 저장해라. 제품 실행하기개요 탭에서 &ldquo;Synchronize&rdquo; 를 누른뒤 &ldquo;Launch an Eclipse application&rdquo; 누른다. 동기화는 실행 설정과 제품 설정을 맞출 것이다. 스플래시 화면&ldquo;Splash&rdquo; 탭은 스플래시 화면을 포함하는 플러그인을 명세한다. 프로젝트 디렉토리에 &ldquo;splash.bmp&rdquo; 파일을 넣어야한다. 이름과 포맷은 하드 코드되어 있고 변경될 수 없다. 상응하는 설정을 설정한다. 마음에 드는 그래픽 도구를 통해 &ldquo;splash.bmp&rdquo; 파일을 생성하고 &ldquo;de.vogella.rcp.intro.deploy&rdquo; 프로젝트에 저장한다. 또한 메시지를 추가하고, 스플래시 화면에 진행 막대를 추가할 수 있다. 어플리케이션을 시작하면 스플래시 화면을 볼 수 있을 것이다. 예를 들어 나는 나의 웹 페이지의 스크린 샷을 사용한다. 제품을 브랜딩하기표준 이클립스 정보 대화창은 브랜드 될 수 있다. 어플리케이션에 아이콘과 텍스트를 추가할 수 있다. 이 예제에서는 이 것을 사용하지 않았다. 메뉴에 &ldquo;About dialog&rdquo; 가 보이기 위해 표준 명령인 &ldquo;org.eclipse.ui.help.about&rdquo; 을 추가한다. 이클립스 표준 명령을 사용하는 방법에 대한 정보는 이클립스 명령 따라하기 를 보아라. 시작 아이콘과 실행 인자 변경하기이 예제에서는 이것이 쓰이지 않는다. 런처는 제품의 배포시에 생성되는 실행가능한 프로그램이다. 기본적으로 &ldquo;eclipse.exe&rdquo; 당 하나의 &ldquo;eclipse&rdquo; 아이콘이 생성된다. 이를 변경하기 위해 제품 설정의 런처 탭을 선택한다. 여기서 어플리케이션의 이름과 사용될 아이콘을 명세할 수 있다. 아이콘의 깊이가 완전히 기입되지 않으면 이클립스는 이 아이콘들을 사용하지 않는다. 런처 섹션에서 이클립스 프로그램이나 JVM 인자들을 명세할 수 있다. 지금까지 제품 설정을 하였다. 다음 단원에서는 이클립스 외부에서 실행될 수 있는 독립형 프로그램과 같은 제품을 생성하기 위한 설정을 이용하는 방법에 대해 설명할 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial12","slug":"eclipse-rcp-tutorial12","date":"2014-06-01T01:51:00.000Z","updated":"2017-04-09T03:42:57.155Z","comments":true,"path":"2014/06/01/eclipse-rcp-tutorial12/","link":"","permalink":"http://sarojaba.github.io/2014/06/01/eclipse-rcp-tutorial12/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 퍼스펙티브퍼스펙티브는 특정 작업과 관련된 UI 요소들을 함께 묶고 조직화한다. 이클립스 RCP 는 어플리케이션에 퍼스펙티브를 추가할 수 있도록 한다. 다음 예제를 보자. 어플리케이션에 퍼스펙티브 추가하기&ldquo;de.vogella.rcp.intro.perspective&rdquo; 라는 이름으로 RCP 프로젝트를 생성한다. 템플릿은 &ldquo;RCP application with a view&rdquo; 를 사용한다. &ldquo;plugin.xml&rdquo; 에 &ldquo;org.eclipse.ui.perspective&rdquo; 확장점을 추가한다. 퍼스펙티브의 id 에 &ldquo;de.vogella.rcp.intro.perspective.perspective&rdquo; 를, 이름에 &ldquo;vogella.de Perspective&rdquo; 를 적는다. 클래스 이름은 &ldquo;de.vogella.rcp.intro.perspective.Perspective&rdquo; 로 변경한다. &ldquo;class*&rdquo; 링크를 눌러 클래스를 생성한다. 새 클래스의 createInitialLayout() 메소드는 새로운 퍼스펙티브를 생성을 책임진다. 기존의 뷰의 코드를 재사용한다. 다음 단계에서 퍼스펙티브는 정의되지만 어플리케이션에서 사용할 수 없다. package de.vogella.rcp.intro.perspective; import org.eclipse.ui.IPageLayout; import org.eclipse.ui.IPerspectiveFactory; public class Perspective implements IPerspectiveFactory { public void createInitialLayout(IPageLayout layout) { String editorArea = layout.getEditorArea(); layout.setEditorAreaVisible(false); layout.setFixed(true); layout.addStandaloneView(View.ID, false, IPageLayout.LEFT, 1.0f, editorArea); } } `&lt;/pre&gt; ## 퍼스펙티브 선택하기 ## 툴바/쿨바를 통해 퍼스펙티브 선택하기 ApplicationWorkbenchWindowAdvisor 클래스의 preWindowOpen() 메소드 내에 configurer.setShowPerspectiveBar(true); 를 통해 퍼스펙티브간의 변경을 활성화 할 수 있다. &lt;pre&gt;`package perspectivetest; import org.eclipse.jface.preference.IPreferenceStore; import org.eclipse.swt.graphics.Point; import org.eclipse.ui.IWorkbenchPreferenceConstants; import org.eclipse.ui.PlatformUI; import org.eclipse.ui.application.ActionBarAdvisor; import org.eclipse.ui.application.IActionBarConfigurer; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchWindowAdvisor; public class ApplicationWorkbenchWindowAdvisor extends WorkbenchWindowAdvisor { public ApplicationWorkbenchWindowAdvisor( IWorkbenchWindowConfigurer configurer) { super(configurer); } public ActionBarAdvisor createActionBarAdvisor( IActionBarConfigurer configurer) { return new ApplicationActionBarAdvisor(configurer); } public void preWindowOpen() { IWorkbenchWindowConfigurer configurer = getWindowConfigurer(); configurer.setInitialSize(new Point(400, 300)); configurer.setShowCoolBar(false); configurer.setShowStatusLine(false); configurer.setTitle(&quot;RCP Application&quot;); configurer.setShowPerspectiveBar(true); // Set the preference toolbar to the left place // If other menus exists then this will be on the left of them IPreferenceStore apiStore = PlatformUI.getPreferenceStore(); apiStore.setValue(IWorkbenchPreferenceConstants.DOCK_PERSPECTIVE_BAR, &quot;TOP_LEFT&quot;); } } 이제 퍼스펙티브를 즉각적으로 변경할 수 있다. 메뉴를 통해 퍼스펙티브 선택하기이클립스 퍼스펙티브를 바꾸는 것은 메뉴의 표준 명령인 &ldquo;org.eclipse.ui.perspectives.showPerspective&rdquo; 를 통해 재사용할 수 있다. 이클립스 커맨드 을 참고하라.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial11","slug":"eclipse-rcp-tutorial11","date":"2014-05-31T11:45:00.000Z","updated":"2017-04-09T03:43:18.983Z","comments":true,"path":"2014/05/31/eclipse-rcp-tutorial11/","link":"","permalink":"http://sarojaba.github.io/2014/05/31/eclipse-rcp-tutorial11/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 상태표시줄 추가하기상태표시줄 설정하기&ldquo;de.vogella.rcp.intro.statusline&rdquo; 으로 새로운 RCP 프로젝트를 생성한다. 템플릿으로 &ldquo;Hello RCP&rdquo; 를 사용한다. &ldquo;ApplicationWorkbenchWindowAdvisor&rdquo; 클래스를 열고 preWindowOpen() 메소드를 변경한다. 코드에서 관련된 위치는 &ldquo;configurer.setShowStatusLine(true);&rdquo; 이다. package de.vogella.rcp.intro.statusline; import org.eclipse.swt.graphics.Point; import org.eclipse.ui.application.ActionBarAdvisor; import org.eclipse.ui.application.IActionBarConfigurer; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchWindowAdvisor; public class ApplicationWorkbenchWindowAdvisor extends WorkbenchWindowAdvisor { public ApplicationWorkbenchWindowAdvisor(IWorkbenchWindowConfigurer configurer) { super(configurer); } public ActionBarAdvisor createActionBarAdvisor(IActionBarConfigurer configurer) { return new ApplicationActionBarAdvisor(configurer); } @Override public void preWindowOpen() { IWorkbenchWindowConfigurer configurer = getWindowConfigurer(); configurer.setInitialSize(new Point(400, 300)); configurer.setShowCoolBar(false); configurer.setShowStatusLine(false); configurer.setTitle(&quot;Status Line Example&quot;); configurer.setShowStatusLine(true); } } `&lt;/pre&gt; 애플리케이션을 실행하면 이미 상태표시줄을 볼 수 있을 것이다. 중요한 점은 상태표시줄은 텍스트를 포함하지 않는다는 것이다. ## 공유된 상태표시줄 공유된 메시지 영역은 이 영역에 메시지를 쓰기위해 애플리케이션의 모든 영역에서 사용될 수 있다. 다음은 상태표시줄에 텍스트를 쓰는 코드이다. &lt;pre&gt;`package de.vogella.rcp.intro.statusline; import org.eclipse.jface.action.IStatusLineManager; import org.eclipse.swt.graphics.Point; import org.eclipse.ui.application.ActionBarAdvisor; import org.eclipse.ui.application.IActionBarConfigurer; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchWindowAdvisor; public class ApplicationWorkbenchWindowAdvisor extends WorkbenchWindowAdvisor { public ApplicationWorkbenchWindowAdvisor(IWorkbenchWindowConfigurer configurer) { super(configurer); } public ActionBarAdvisor createActionBarAdvisor(IActionBarConfigurer configurer) { return new ApplicationActionBarAdvisor(configurer); } @Override public void preWindowOpen() { IWorkbenchWindowConfigurer configurer = getWindowConfigurer(); configurer.setInitialSize(new Point(400, 300)); configurer.setShowCoolBar(false); configurer.setShowStatusLine(false); configurer.setTitle(&quot;Status Line Example&quot;); configurer.setShowStatusLine(true); } // This is the new method @Override public void postWindowOpen() { IStatusLineManager statusline = getWindowConfigurer() .getActionBarConfigurer().getStatusLineManager(); statusline.setMessage(null, &quot;Status line is ready&quot;); } } `&lt;/pre&gt; 애플리케이션을 실행한다. 다음과 같은 화면을 볼 수 있을 것이다. ID가 “de.vogella.rcp.intro.statusline.View1” 인 뷰를 추가하고 “de.vogella.rcp.intro.statusline.ViewPart1” 클래스를 구현한다. 이 뷰는 상태표시줄을설정하는 버튼을 포함한다. &lt;pre&gt;`package de.vogella.rcp.intro.statusline; import org.eclipse.swt.SWT; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Composite; import org.eclipse.ui.IActionBars; import org.eclipse.ui.part.ViewPart; public class ViewPart1 extends ViewPart { boolean pressed = false; @Override public void createPartControl(Composite parent) { Button setStatusLine = new Button(parent, SWT.PUSH); setStatusLine.setText(&quot;Set Statusline &quot;); setStatusLine.addSelectionListener(new SelectionAdapter() { public void widgetSelected(SelectionEvent e) { String message = &quot;I would like to say hello to you.&quot;; if (pressed) { message = &quot;Thank you for using me&quot;; } setStatusLine(message); pressed = !pressed; } }); } private void setStatusLine(String message) { // Get the status line and set the text IActionBars bars = getViewSite().getActionBars(); bars.getStatusLineManager().setMessage(message); } @Override public void setFocus() { } } 결과를 실행하면 다음과 같은 화면을 볼 수 있다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial10","slug":"eclipse-rcp-tutorial10","date":"2014-05-31T11:34:00.000Z","updated":"2017-04-09T03:43:34.636Z","comments":true,"path":"2014/05/31/eclipse-rcp-tutorial10/","link":"","permalink":"http://sarojaba.github.io/2014/05/31/eclipse-rcp-tutorial10/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 JFace 뷰어개요JFace는 사용자 인터페이스를 생성시 자바 객체를 바로 사용할 수 있는 뷰어를 제공한다. 뷰어는 트리, 테이블, 리스트와 콤보박스가 가능하다. 다음에서 콤보 뷰어의 사용 예를 보여줄 것이다. 테이블 뷰어의 자세한 사용법은 Eclipse JFaces Tables 에서 찾을 수 있다. 트리 뷰어의 간략한 사용 예는 JFace Tree Viewer 에서 찾을 수 있다. 콤보뷰어새로운 RCP 프로젝트 &ldquo;de.vogella.rcp.intro.jfaceviewer&rdquo; 를 만들고 &ldquo;RCP application with a view&rdquo; 템플릿을 선택한다. 다음의 자바 클래스를 생성한다. package de.vogella.rcp.intro.jfaceviewer; public class Person { private String firstName; private String lastName; public Person(String firstName, String lastName){ this.firstName = firstName; this.lastName = lastName; } public String getFirstName() { return firstName; } public void setFirstName(String firstName) { this.firstName = firstName; } public String getLastName() { return lastName; } public void setLastName(String lastName) { this.lastName = lastName; } } `&lt;/pre&gt; View.java 를 다음과 같이 변경한다. &lt;pre&gt;`package de.vogella.rcp.intro.jfaceviewer; import org.eclipse.jface.viewers.ArrayContentProvider; public class View extends ViewPart { public static final String ID = &quot;de.vogella.rcp.intro.jfaceviewer.view&quot;; private ComboViewer viewer; public void createPartControl(Composite parent) { GridLayout layout = new GridLayout(2, false); parent.setLayout(layout); Label label = new Label(parent, SWT.NONE); label.setText(&quot;Select a person:&quot;); viewer = new ComboViewer(parent, SWT.READ_ONLY); viewer.setContentProvider(new ArrayContentProvider()); viewer.setLabelProvider(new LabelProvider() { @Override public String getText(Object element) { if (element instanceof Person) { Person person = (Person) element; return person.getFirstName(); } return super.getText(element); } }); Person[] persons = new Person[] { new Person(&quot;Lars&quot;, &quot;Vogel&quot;), new Person(&quot;Tim&quot;, &quot;Taler&quot;), new Person(&quot;Jim&quot;, &quot;Knopf&quot;) }; // Set set the input to the viewer this input will be send to the // content provider viewer.setInput(persons); // React to the selection of the viewer // Note that the viewer return the real object and not just a string // representation viewer.addSelectionChangedListener(new ISelectionChangedListener() { @Override public void selectionChanged(SelectionChangedEvent event) { IStructuredSelection selection = (IStructuredSelection) event .getSelection(); System.out.println(((Person) selection.getFirstElement()) .getLastName()); } }); // You can select a object directly via the domain object Person person = persons[0]; viewer.setSelection(new StructuredSelection(person)); } /** * Passing the focus request to the viewer&apos;s control. */ public void setFocus() { viewer.getControl().setFocus(); } }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial9","slug":"eclipse-rcp-tutorial9","date":"2014-05-31T11:27:00.000Z","updated":"2017-04-09T03:44:10.796Z","comments":true,"path":"2014/05/31/eclipse-rcp-tutorial9/","link":"","permalink":"http://sarojaba.github.io/2014/05/31/eclipse-rcp-tutorial9/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 필드 어시스트와 레이블 데코레이터필드 어시스트는 텍스트 필드나 콤보 박스와 같이 단순 필드의 가능한 입력과 상태에 대한 정보를 제공하는데 사용될 수 있다. &ldquo;org.eclipse.jface.fieldassist&rdquo; 패키지는 ControlDecorations 와 Content Proposals 두 가지 방법으로 도움을 제공한다. 콘트롤 장식은 콘트롤에 대한 부가적인 정보를 보여주기 위해 SWT 컨트롤에 이미지 장식을 두도록 한다. 이 장식은 사용자가 마우스를 올려 놓았을때 한번 보여지는 내용을 가지고 있을 수 있다. 화면 배치 중에 이 장식들을 보여주기 위한 충반한 공간이 있다고 확신해야 한다. 컨텐트 제안은 필드에 사용자 입력에 대해 가능한 선택을 도와주도록 한다. &ldquo;de.vogella.rcp.intro.fieldassist&rdquo; 로 새 프로젝트를 생성한다. 예제로 &ldquo;RCP application with a view&rdquo; 를 사용한다. 예제에서 컨텐트 제안은 &ldquo;Cntrl+Space&rdquo; 키 조합으로 특정 키(&ldquo;.&rdquo;, &ldquo;#&rdquo;)를 통해 활성화된다. 다음으로 View.java를 바꾼다. package de.vogella.rcp.intro.fieldassist; import org.eclipse.jface.bindings.keys.KeyStroke; import org.eclipse.jface.bindings.keys.ParseException; import org.eclipse.jface.fieldassist.ContentProposalAdapter; import org.eclipse.jface.fieldassist.ControlDecoration; import org.eclipse.jface.fieldassist.FieldDecorationRegistry; import org.eclipse.jface.fieldassist.SimpleContentProposalProvider; import org.eclipse.jface.fieldassist.TextContentAdapter; import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Text; import org.eclipse.ui.part.ViewPart; public class View extends ViewPart { public static final String ID = &quot;de.vogella.rcp.intro.fieldassist.view&quot;; public void createPartControl(Composite parent) { GridLayout layout = new GridLayout(2,false); parent.setLayout(layout); Label label = new Label(parent, SWT.NONE); label.setText(&quot;Please select a value: &quot;); Text text = new Text(parent, SWT.BORDER); createDeco(text, &quot;Use CNTL + SPACE to see possible values&quot;); GridData data = new GridData(GridData.FILL_HORIZONTAL); text.setLayoutData(data); ControlDecoration deco = new ControlDecoration(text, SWT.LEFT); deco.setDescriptionText(&quot;Use CNTL + SPACE to see possible values&quot;); deco.setImage(FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_INFORMATION).getImage()); deco.setShowOnlyOnFocus(false); // Help the user with the possible inputs // &quot;.&quot; and &quot;#&quot; will also activate the content proposals char[] autoActivationCharacters = new char[] { &apos;.&apos;, &apos;#&apos; }; KeyStroke keyStroke; try { // keyStroke = KeyStroke.getInstance(&quot;Ctrl+Space&quot;); // assume that myTextControl has already been created in some way ContentProposalAdapter adapter = new ContentProposalAdapter(text, new TextContentAdapter(), new SimpleContentProposalProvider(new String[] { &quot;ProposalOne&quot;, &quot;ProposalTwo&quot;, &quot;ProposalThree&quot; }), keyStroke, autoActivationCharacters); } catch (ParseException e) { e.printStackTrace(); } } public void setFocus() { } private void createDeco(Text text, String s){ } } 애플리케이션을 실행하고 콘트롤 장식과 컨텐트 제안이 작동하는지 확인한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial8","slug":"eclipse-rcp-tutorial8","date":"2014-05-31T11:24:00.000Z","updated":"2017-04-09T03:44:51.831Z","comments":true,"path":"2014/05/31/eclipse-rcp-tutorial8/","link":"","permalink":"http://sarojaba.github.io/2014/05/31/eclipse-rcp-tutorial8/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 뷰개요뷰와 뷰 파트는 어플리케이션에서 정보를 보여주고 데이터를 변경하는 데에 사용된다. 다음은 어플리케이션에 뷰를 추가하는 방법을 설명한다. &ldquo;de.vogella.rcp.intro.view&rdquo; 라는 이름의 RCP 프로젝트를 생성하라. &ldquo;Hello RCP&rdquo; 템플릿을 사용하라. 뷰 생성하기플러그인에 &ldquo;org.eclipse.ui.views&rdquo; 확장을 추가한다. 새로운 뷰 확장에 마우스 오른쪽 클릭을 하고 New -&gt; View 를 선택한다. id 는 &ldquo;de.vogella.rcp.intro.view.MyView&rdquo;, 클래스는 &ldquo;de.vogella.rcp.intro.view.MyView&rdquo; 로 설정한다. &ldquo;class&rdquo; 하이퍼링크를 클릭하여 &ldquo;MyView&rdquo; 클래스를 생성하고 다음의 코드를 작성하라. 그러면 뷰를 사용할 준비가 된다. package de.vogella.rcp.intro.view; import org.eclipse.swt.SWT; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Text; import org.eclipse.ui.part.ViewPart; public class MyView extends ViewPart { @Override public void createPartControl(Composite parent) { Text text = new Text(parent, SWT.BORDER); text.setText(&quot;Imagine a fantastic user interface here&quot;); } @Override public void setFocus() { } } `&lt;/pre&gt; ## 퍼스펙티브에 뷰 추가하기 당신의 퍼스펙티브에 뷰를 추가해야 한다. 플러그인에 “org.eclipse.ui.perspectiveExtensions” 확장을 추가한다. 오른쪽 클릭을 하고 뷰를 선택한다. id 로 “de.vogella.rcp.intro.view.MyView” 를 기입한다. relative 는 현재 안보이는 편집 영역인 “org.eclipse.ui.editorss” 를 적고 “0.95f” 의 최대 비율을 선택함으로써 모든 여백을 사용한다. ## 결과 결과를 보기 위해 어플리케이션을 실행한다. ## 코드를 통해 퍼스펙티브에 뷰를 추가하기 나는 개인적으로 코드 상의 확장점을 더 선호한다. 하지만 “org.eclipse.ui.perspectiveExtensions” 확장점을 사용하는 대신 퍼스펙티브로 코드를 통해 뷰를 추가할 수도 있다. 다음의 변경된 “Perspective.java” 파일을 보자. &lt;pre&gt;`package de.vogella.rcp.intro.view; import org.eclipse.ui.IPageLayout; import org.eclipse.ui.IPerspectiveFactory; public class Perspective implements IPerspectiveFactory { public void createInitialLayout(IPageLayout layout) { layout.addView(&quot;de.vogella.rcp.intro.view.MyView&quot;, IPageLayout.TOP, IPageLayout.RATIO_MAX, IPageLayout.ID_EDITOR_AREA); } } 에디터 / 뷰 상호작용이클립스 에디터를 사용하고 뷰와 에디터 사이의 통신을 하는 방법을 배우려면 Eclipse Editors 를 보아라.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial7","slug":"eclipse-rcp-tutorial7","date":"2014-05-24T12:12:00.000Z","updated":"2017-04-09T03:45:16.833Z","comments":true,"path":"2014/05/24/eclipse-rcp-tutorial7/","link":"","permalink":"http://sarojaba.github.io/2014/05/24/eclipse-rcp-tutorial7/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 시스템 트레이다음은 시스템 트레이의 RCP 어플리케이션에 아이콘을 추가하고, 이 아이콘에 메뉴를 추가하는 것이다. 윈도우가 최소화되면 프로그램이 작업표시줄에서 보이지 않게 되는(트레이 아이콘을 통해서만 보임) 기능을 추가한다. &ldquo;de.vogella.rcp.intro.traytest&rdquo; 라고 프로젝트를 새로 생성한다. &ldquo;Hello RCP&rdquo; 템플릿을 사용한다. 어플리케이션에 &ldquo;de.vogella.rcp.intro.traytest.exitCommand&rdquo; 라는 id 를 가진 명령을 생성한다. &ldquo;ApplicationWorkbenchWindowAdvisor&rdquo; 클래스를 열고 다음의 코드를 적용한다. package de.vogella.rcp.intro.traytest; import org.eclipse.swt.SWT; import org.eclipse.swt.events.ShellAdapter; import org.eclipse.swt.events.ShellEvent; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.MenuItem; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Tray; import org.eclipse.swt.widgets.TrayItem; import org.eclipse.ui.IWorkbenchWindow; import org.eclipse.ui.application.ActionBarAdvisor; import org.eclipse.ui.application.IActionBarConfigurer; import org.eclipse.ui.application.IWorkbenchWindowConfigurer; import org.eclipse.ui.application.WorkbenchWindowAdvisor; import org.eclipse.ui.handlers.IHandlerService; import org.eclipse.ui.plugin.AbstractUIPlugin; public class ApplicationWorkbenchWindowAdvisor extends WorkbenchWindowAdvisor { private IWorkbenchWindow window; private TrayItem trayItem; private Image trayImage; private final static String COMMAND_ID = &quot;de.vogella.rcp.intro.traytest.exitCommand&quot;; public ApplicationWorkbenchWindowAdvisor( IWorkbenchWindowConfigurer configurer) { super(configurer); } public ActionBarAdvisor createActionBarAdvisor( IActionBarConfigurer configurer) { return new ApplicationActionBarAdvisor(configurer); } public void preWindowOpen() { IWorkbenchWindowConfigurer configurer = getWindowConfigurer(); configurer.setInitialSize(new Point(400, 300)); configurer.setShowCoolBar(false); configurer.setShowStatusLine(false); configurer.setTitle(&quot;Hello RCP&quot;); //$NON-NLS-1$ } // As of here is the new stuff @Override public void postWindowOpen() { super.postWindowOpen(); window = getWindowConfigurer().getWindow(); trayItem = initTaskItem(window); // Some OS might not support tray items if (trayItem != null) { minimizeBehavior(); // Create exit and about action on the icon hookPopupMenu(); } } // Add a listener to the shell private void minimizeBehavior() { window.getShell().addShellListener(new ShellAdapter() { // If the window is minimized hide the window public void shellIconified(ShellEvent e) { window.getShell().setVisible(false); } }); // If user double-clicks on the tray icons the application will be // visible again trayItem.addListener(SWT.DefaultSelection, new Listener() { public void handleEvent(Event event) { Shell shell = window.getShell(); if (!shell.isVisible()) { window.getShell().setMinimized(false); shell.setVisible(true); } } }); } // We hook up on menu entry which allows to close the application private void hookPopupMenu() { trayItem.addListener(SWT.MenuDetect, new Listener() { public void handleEvent(Event event) { Menu menu = new Menu(window.getShell(), SWT.POP_UP); // Creates a new menu item that terminates the program // when selected MenuItem exit = new MenuItem(menu, SWT.NONE); exit.setText(&quot;Goodbye!&quot;); exit.addListener(SWT.Selection, new Listener() { public void handleEvent(Event event) { // Lets call our command IHandlerService handlerService = (IHandlerService) window .getService(IHandlerService.class); try { handlerService.executeCommand(COMMAND_ID, null); } catch (Exception ex) { throw new RuntimeException(COMMAND_ID); } } }); // We need to make the menu visible menu.setVisible(true); } }); } // This methods create the tray item and return a reference private TrayItem initTaskItem(IWorkbenchWindow window) { final Tray tray = window.getShell().getDisplay().getSystemTray(); TrayItem trayItem = new TrayItem(tray, SWT.NONE); trayImage = AbstractUIPlugin.imageDescriptorFromPlugin( &quot;de.vogella.rcp.intro.traytest&quot;, &quot;/icons/alt_about.gif&quot;) .createImage(); trayItem.setImage(trayImage); trayItem.setToolTipText(&quot;TrayItem&quot;); return trayItem; } // We need to clean-up after ourself @Override public void dispose() { if (trayImage != null) { trayImage.dispose(); } if (trayItem != null) { trayItem.dispose(); } } } 어플리케이션을 실행하면 시스템 트레이 아이콘을 볼 수 있다. 메뉴와 최소화 동작을 테스트해라. 만약 어플리케이션이 최소화되면 작업표시줄에서 보이지 않게 되고 시스템 트레이에서만 보일 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial6","slug":"eclipse-rcp-tutorial6","date":"2014-05-24T12:09:00.000Z","updated":"2017-04-09T03:45:34.334Z","comments":true,"path":"2014/05/24/eclipse-rcp-tutorial6/","link":"","permalink":"http://sarojaba.github.io/2014/05/24/eclipse-rcp-tutorial6/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1Commands 개요명령은 컴포넌트의 명세를 선언하고 상세 구현으로부터 독립적이다. 명령은 분류할 수 있고 단축키를 할당 할 수 있다. 명령은 메뉴, 툴바 그리고 컨텍스트 메뉴에 사용된다. 다음에서는 메뉴에 명령을 적용하는 방법을 시연할 것이다. 명령에 대한 자세한 내용은 Eclipse Commands - Tutorial 을 보아라. 명령 정의하기어플리케이션을 종료하는 명령을 만들 것이다. &ldquo;de.vogella.rcp.commands.first&rdquo; 라는 새로운 RCP 프로젝트를 생성하고, &ldquo;Hello RCP&rdquo; 템플릿을 사용한다. &ldquo;plugin.xml&rdquo; 파일을 더블 클릭하고 &ldquo;Extensions&rdquo; 탭을 선택한다. 그리고 &ldquo;Add&rdquo; 버튼을 누른다. &ldquo;org.eclipse.ui.commands&rdquo; 확장을 검색한다. 그것을 선택하고 &ldquo;Finish&rdquo; 를 누른다. 확장점에 오른쪽 클릭을 하여 New -&gt; Command 를 선택해 새로운 명령을 생성한다. ID는 &ldquo;de.vogella.rcp.commands.first.commands.Exit&rdquo; 로, 이름은 &ldquo;Exit&rdquo; 로 설정한다. 기본 핸들러로 &ldquo;de.vogella.rcp.commands.first.commands.ExitHandler&rdquo; 클래스를 넣는다. 이 클래스를 생성하기 위해 &ldquo;defaultHAndler&rdquo; 하이퍼링크를 누르고 부모 클래스로 &ldquo;org.eclipse.core.commands.AbstractHandler&rdquo; 를 선택한다. 다음의 코드를 구현한다. 당신의 새로운 명령은 나중에 사용될 준비 상태이다. package de.vogella.rcp.commands.first.commands; import org.eclipse.core.commands.AbstractHandler; import org.eclipse.core.commands.ExecutionEvent; import org.eclipse.core.commands.ExecutionException; import org.eclipse.ui.handlers.HandlerUtil; public class ExitHandler extends AbstractHandler { @Override public Object execute(ExecutionEvent event) throws ExecutionException { HandlerUtil.getActiveWorkbenchWindow(event).close(); return null; } } `&lt;/pre&gt; # 메뉴에서 명령 사용하기 우리가 정의한 명령은 메뉴에서 사용될 것이다. “org.eclipse.ui.commands” 확장과 비슷하게 어플리케이션에 “org.eclipse.ui.menus” 확장점을 추가한다. 확장점에서 오른쪽 클릭을 하고 “New” -&gt; “menuContribution” 을 선택한다. location URI 는 “menu:org.eclipse.ui.main.menu” 라고 하고, 새로운 메뉴 기증을 생성한다. 이 URL이 정확하지 않으면 당신의 메뉴는 보이지 않는다. 메뉴 기증을 오른쪽 클릭하고 “New” -&gt; “Menu” 를 선택한다. label 은 “File”, id 는 “fileMenu” 로 메뉴를 추가한다. 메뉴를 선택하고, 오른쪽 클릭을 하고, New -&gt; Command 를 선택한다. commandID 는 그대로 둔다. 레이블은 “Exit”, 툴팁은 “Exits the application” 으로 설정한다. 위의 과정을 통해 plugin.xml 파일에 다음과 같은 결과를 얻을 것이다. &lt;pre&gt;`&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;?eclipse version=&quot;3.4&quot;?&gt; &lt;plugin&gt; &lt;extension id=&quot;application&quot; point=&quot;org.eclipse.core.runtime.applications&quot;&gt; &lt;application&gt; &lt;run class=&quot;de.vogella.rcp.commands.first.Application&quot;&gt; &lt;/run&gt; &lt;/application&gt; &lt;/extension&gt; &lt;extension point=&quot;org.eclipse.ui.perspectives&quot;&gt; &lt;perspective name=&quot;RCP Perspective&quot; class=&quot;de.vogella.rcp.commands.first.Perspective&quot; id=&quot;de.vogella.rcp.commands.first.perspective&quot;&gt; &lt;/perspective&gt; &lt;/extension&gt; &lt;extension point=&quot;org.eclipse.ui.commands&quot;&gt; &lt;command defaultHandler=&quot;de.vogella.rcp.commands.first.commands.ExitHandler&quot; id=&quot;de.vogella.rcp.commands.first.commands.Exit&quot; name=&quot;Exit&quot;&gt; &lt;/command&gt; &lt;/extension&gt; &lt;extension point=&quot;org.eclipse.ui.menus&quot;&gt; &lt;menuContribution locationURI=&quot;menu:org.eclipse.ui.main.menu&quot;&gt; &lt;menu id=&quot;fileMenu&quot; label=&quot;File&quot;&gt; &lt;command commandId=&quot;de.vogella.rcp.commands.first.commands.Exit&quot; label=&quot;Exit&quot; style=&quot;push&quot; tooltip=&quot;Exit the application&quot;&gt; &lt;/command&gt; &lt;/menu&gt; &lt;/menuContribution&gt; &lt;/extension&gt; &lt;/plugin&gt; 예제를 실행한다. &ldquo;file&rdquo; 메뉴를 보게 될 것이고, &ldquo;Exit&rdquo; 항목을 선택하면 어플리케이션은 종료할 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial4-5","slug":"eclipse-rcp-tutorial4-5","date":"2014-05-20T14:22:00.000Z","updated":"2017-04-09T03:45:55.959Z","comments":true,"path":"2014/05/20/eclipse-rcp-tutorial4-5/","link":"","permalink":"http://sarojaba.github.io/2014/05/20/eclipse-rcp-tutorial4-5/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 동작 과정과 어드바이저이클립스 RCP 어플리케이션을 시작하는 동안 이클립스 런타임은 &ldquo;org.eclipse.core.runtime.application&rdquo; 확장점을 통해 정의된 클래스를 평가할 것이다. 이 클래스는 로드되고 생성되고 워크벤치를 실행할 것이다. 워크벤치는 &ldquo;WorkbenchAdvisor&rdquo; 를 통해 설정된다. 워크벤치는 WorkbenchWindowAdvisor 를 통해 설정된 &ldquo;WorkbenchWindow&rdquo; 를 실행할 것이다. 이 WorkbenchWindow 는 &ldquo;ActionBarAdvisor&rdquo; 를 통해 시작 설정된 어플리케이션의 툴바를 생성할 것이다. 각 어드바이저는 어플리케이션의 특정 행동을 설정하도록 한다. 예를 들어, 워크벤치 어드바이저는 preStartUp() 과 preShutdown() 메소드를 오버라이딩 함으로써 시작이나 종료시 특정 행동을 수행하도록 한다. 동작 설정하기개요이클립스의 동작 설정은 당신의 어플리케이션이 시작될 환경을 정의한다. 예를들어, 컴파일러 플래그, 플러그인(클래스 패스) 종속성 등. 때때로 동작 환경은 &ldquo;실행 환경&rdquo; 이라고도 불린다. 만약 당신이 RCP 어플리케이션을 시작한다면 동작 설정은 자동으로 생성될 것이다. 동작 설정을 보고 변경하기 위해 &ldquo;MANIFEST.MF&rdquo; 파일을 선택하고, 오른쪽 클릭해서 Run As -&gt; Run Configurations 를 선택한다. &ldquo;location&rdquo; 필드는 RCP 어플리케이션을 실행하기 위한 필요한 파일들이 생성될 곳을 나타낸다. 런타임 설정 검사하기&ldquo;Plug-ins&rdquo; 탭의 &ldquo;Validate plug-ins prior to launching&rdquo; 을 선택한다. 이것은 당신의 실행 설정에 필요한 플러그인을 모두 가지고 있는지 검사할 것이다. 만약 플러그인이 빠졌다고 보고되면, &ldquo;Add Required-Plug-Ins&rdquo; 버튼을 눌러 보아라. &ldquo;Arguments&rdquo; 탭에서 &ldquo;-consoleLog&rdquo; 인자를 찾을 수 있을 것이다. 이 옵션은 콘솔 뷰에서 RCP 어플리케이션의 에러를 볼 수 있도록 하며, 문제를 인식하는데 많은 도움이 될 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial3","slug":"eclipse-rcp-tutorial3","date":"2014-05-20T14:20:00.000Z","updated":"2017-04-09T03:46:33.005Z","comments":true,"path":"2014/05/20/eclipse-rcp-tutorial3/","link":"","permalink":"http://sarojaba.github.io/2014/05/20/eclipse-rcp-tutorial3/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 처음으로 RCP 어플리케이션 생성하기다음은 간단한 RCP 어플리케이션을 생성하는 방법에 대한 빠른 설명을 제시한다. RCP 어플리케이션 생성하기이클립스에서 File -&gt; New Project 를 선택한다. 리스트에서 Plug-In Project 를 선택한다. 플러그인 이름을 &ldquo;de.vogella.rcp.intro.first&rdquo; 라고 적는다. &ldquo;Next&rdquo; 을 누르고 다음에 나오는 설정을 적는다. RCP 어플리케이션을 만들것이므로 &ldquo;Would you like to create a rich client application&rdquo; 질문에 &ldquo;Yes&rdquo; 를 선택한다. &ldquo;Next&rdquo; 를 누르고, &ldquo;Hello RCP&rdquo; 템플릿을 선택한다. &ldquo;Next&rdquo; 를 누르고, &ldquo;Add branding&quot;을 선택하고, &quot;Finish&rdquo; 를 누른다. 마침내 아래의 프로젝트 구조를 가지는 프로젝트가 생성될 것이다. 프로젝트 구조에 대한 첫 느낌을 얻기위해 자바 파일들과 특히 다른 파일들을 훑어보아라. RCP 어플리케이션 실행하기&ldquo;MANIFEST.MF&rdquo; 파일을 더블클릭하여 연다. 에디터를 보게될 것이고, &ldquo;Overview&rdquo; 탭이 선택되어 있을 것이다. &ldquo;Launch an Eclipse Application&rdquo; 링크를 클릭한다. 결과로 다음과 같은 모습을 볼 것이다. 당신의 첫 RCP 어플리케이션이 만들어진 것에 대해 축하한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial2","slug":"eclipse-rcp-tutorial2","date":"2014-05-17T03:12:00.000Z","updated":"2017-04-09T03:46:51.585Z","comments":true,"path":"2014/05/17/eclipse-rcp-tutorial2/","link":"","permalink":"http://sarojaba.github.io/2014/05/17/eclipse-rcp-tutorial2/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 설치하기설치하기Eclipse.org 홈페이지에서 DOWNLOADS 를 클릭한다. &ldquo;Eclipse for RCP/Plug-in Developers&rdquo; 패키지를 다운로드 한다. 하드 디스크에 압축을 푼다. 이클립스 경로에는 특수 문자나 공백을 피한다. 이클립스 자바 IDE 업데이트하기이미 이클립스 자바 IDE 배포판을 다운 받았을 경우, RCP 개발에 필요한 플러그인을 인스톨하기 위해 이클립스 업데이트 매니저를 이용할 수 있다. 업데이트 매니저를 사용하는 자세한 사항은 Eclipse Update Manager 에서 참고하라. 헬리오스 업데이트 사이트에서 &ldquo;General Purpose Tools&rdquo; -&gt; &ldquo;Eclipse Plug-in Development Environment&rdquo; 와 &ldquo;Eclipse RCP Plug-in Developer Resources&rdquo; 를 설치한다. 이 기능들을 보기 위해 아마도 &ldquo;Group items by category&rdquo; 플래그를 없애야 할 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"eclipse-rcp-tutorial1","slug":"eclipse-rcp-tutorial1","date":"2014-05-15T16:53:00.000Z","updated":"2017-04-09T03:47:07.826Z","comments":true,"path":"2014/05/16/eclipse-rcp-tutorial1/","link":"","permalink":"http://sarojaba.github.io/2014/05/16/eclipse-rcp-tutorial1/","excerpt":"","text":"작성일: 2010. 10. 27. 원문: http://www.vogella.de/articles/EclipseRCP/article.html Version 5.1 이클립스 RCP이 튜토리얼은 이클립스 RCP 어플리케이션을 개발하는 방법을 적고있다. 이클립스 3.6(헬리오스)에 기반을 두고 있다. 이클립스 RCP다음에 나오는 내용은 이미 이클립스 IDE를 사용하는 방법을 안다고 가정하고 있다. 개요이클립스 RCP 는 개발자가 이클립스 플랫폼을 이용하여 유연하고 확장성있는 데스크탑 어플리케이션을 작성하도록 한다. 이클립스는 플러그인 아키텍처를 기반으로 설계되었다. 플러그인은 이클립스에서 배포와 설치가 가능한 가장 작은 소프트웨어 컴포넌트이다. 이 아키텍처는 이클립스 어플리케이션이 서드 파티에 의해 확장될 수 있도록 한다. 이클립스 RCP 는 독립형 어플리케이션에도 동일한 모듈 개념을 제공한다. 이클립스 IDE의 컴포넌트들은 일반적으로 다음과 같다. 이클립스 RCP 어플리케이션은 이들 컴포넌트들의 부분들을 사용하는 것을 결정할 수 있다. 이것은 양식없는 이클립스 기반의 어플리케이션을 설계하는 것을 가능하게 하고, 단지 런타임만 필요하다. 이클립스 RCP 어플리케이션은 일반적으로 다음을 사용한다. 이클립스 RCP 어플리케이션(UI 포함)을 작성하고 실행하기 위해 필요한 최소한의 플러그인은 &ldquo;org.eclipse.core.runtime&rdquo; 과 &ldquo;org.eclipse.ui&rdquo; 이다. OSGI 런타임은 모듈형 어플리케이션을 구동할 수 있는 프레임워크를 제공한다. SWT 는 이클립스에서 사용되는 표준 UI 컴포넌트 라이브러리이고 JFace 는 SWT 위에서 편리한 API 를 제공한다. 워크벤치는 다른 모든 UI 컴포넌트들이 보여지는 어플리케이션의 프레임을 제공한다. 이클립스 RCP 아키텍처이클립스의 가장 중요한 아키텍처상의 특징은 플러그인 아키텍처이다. 이클립스 어플리케이션은 API와 종속성이의되어 있는 수많은 플러그인으로 구성되어있다. 이 아키텍처는 OSGI 의 참조 구현인 Equinox 런타임 환경을 기초로 하고 있다. 이클립스는 &ldquo;Plugin&rdquo; 이라는 용어를 사용하고 OSGI 는 &ldquo;bundle&rdquo; 이라는 용어를 사용하지만, 두 용어의 뜻은 같다. OSGI는 이클립스 플러그인이 다음을 정의하도록 한다. their API - 다른 플러그인이 사용할 수 있는 공개된 클래스들 their 종속성 - 플러그인이 정확히 동작할 수 있는데 필수적인 패키지나 플러그인들 각 플러그인은 다른 플러그인들을 통해 기능을 기여하는 것이 가능하도록 정의하는 확장점을 정의하고 있다. 플러그인은 확장(이 확장점을 기능적으로 제공하는)을 이용할 수 있다. 확장과 확장점은 plugin.xml 파일에 기술된다. 이 파일은 PDE(플러그인 개발 환경)을 통해 편집될 수 있는 XML 파일이다. PDE 는 이 파일을 편집할 수 있는 사용자 인터페이스를 제공한다. 이 확장들은 이클립스 RCP 어플리케이션이 구동될 때 수집된다. 확장점의 정보는 디스크립터로 불리는 것으로 변환되고 레지스트리에 저장된다. 이클립스 RCP 어플리케이션의 주요 컴포넌트이클립스 RCP 어플리케이션은 다음의 요소들을 필요로 한다. 컴포넌트의 정의는 이 튜토리얼의 후반부에서 설명될 것이다. 메인 프로그램 - RCP 메인 어플리케이션 클래스는 IApplication 인터페이스를 구현한다. 이 클래스는 표준 자바 어플리케이션을 위한 메인 메소드와 동일하다고 볼 수 있다. 이클립스는 어플리케이션 클래스가 org.eclipse.core.runtime.application 확장점을 통해서 정의되는 것을 기대한다. 퍼스펙티브 - 퍼스펙티브는 org.eclipse.ui.perspective 에서 확장된다. 워크벤치 어드바이저 - 어플리케이션의 외형(메뉴, 툴바, 퍼스펙티브 등등)을 제어하는 보이지 않는 기술적 컴포넌트이다. 설정 파일이클립스 RCP 어플리케이션은 두 개의 주요 설정 파일을 가진다. MANIFEST.MF - OSGI 설정 정보를 포함한다. plugin.xml - 확장과 확장점에 대한 정보","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"RCP","slug":"RCP","permalink":"http://sarojaba.github.io/tags/RCP/"},{"name":"Tutorial","slug":"Tutorial","permalink":"http://sarojaba.github.io/tags/Tutorial/"}]},{"title":"제5회-대학생-프로그래밍-경시대회-문제-b-ktx","slug":"제5회-대학생-프로그래밍-경시대회-문제-b-ktx","date":"2014-05-15T16:46:00.000Z","updated":"2017-04-09T03:47:43.075Z","comments":true,"path":"2014/05/16/제5회-대학생-프로그래밍-경시대회-문제-b-ktx/","link":"","permalink":"http://sarojaba.github.io/2014/05/16/제5회-대학생-프로그래밍-경시대회-문제-b-ktx/","excerpt":"","text":"소스코드public class KTX { public static void main(String[] args) { //int[] order = {3, 2, 1}; int[] order = {2, 4, 5, 3, 1}; System.out.println(isOrder(order)); } public static boolean isOrder(int[] order) { int route1 = -1, route2 = -1; // 두 우회로에 있는 열차의 등급(현재는 비어있다.) int grade = 1; // 현재 도착해야 하는 열차의 등급 for(int i = 0; i &lt; order.length; i++) { // 선두 열차가 현재 최고 등급이라면 지나간다. if(order[i] == grade) { grade++; } // 처음 우회로에 현재 최고 등급의 열차가 있으면 지나간다. else if(route1 == grade) { route1 = -1; grade++; } // 다음 우회로에 현재 최고 등급의 열차가 있으면 지나간다. else if(route2 == grade) { route2 = -1; grade++; } // 처음 우회로가 비어있으면 거기로 보낸다. else if(route1 == -1) { route1 = order[i]; } // 두번째 우회로가 비어있으면 거기로 보낸다. else if(route2 == -1) { route2 = order[i]; } // 위의 모든 경우가 아니라면 순서대로 보내는 것은 불가능이다. else { return false; } } // 모든 열차가 지나갔다면 순서대로 보내는 것이 성공했다. return true; } } 주절주절이 문제도 너무 옛날에 풀어서 정확히 기억이 안난다. 시간나면 다시 풀어보아야겠다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"제5회-대학생-프로그래밍-경시대회-문제-a-장보기","slug":"제5회-대학생-프로그래밍-경시대회-문제-a-장보기","date":"2014-05-14T16:23:00.000Z","updated":"2017-04-09T03:48:21.184Z","comments":true,"path":"2014/05/15/제5회-대학생-프로그래밍-경시대회-문제-a-장보기/","link":"","permalink":"http://sarojaba.github.io/2014/05/15/제5회-대학생-프로그래밍-경시대회-문제-a-장보기/","excerpt":"","text":"소스코드public class Shopping { public static void main(String[] args) { /*int[][] order = { {300, 2000}, {200, 1500} };*/ /*int[][] order = { {320, 2139}, {700, 3200}, {1400, 6400} };*/ int[][] order = { {250, 1920}, {500, 2980}, {430, 2700}, {380, 2350}, {340, 2310} }; System.out.println(choose(order)); } public static int choose(int[][] order) { // 1g 당 가격의 최소값 long min = Long.MAX_VALUE; // 그 때의 원래 가격 int cost = 0; for(int i = 0; i &lt; order.length; i++) { // 현재 물건의 1g 당 가격 long p = order[i][1] / order[i][0]; // 기존의 물건 보다도 중량 대비 더 싸다면 가격을 저장한다. if(p &lt; min) { min = p; cost = order[i][1]; } else if(p == min) { // 같다면 더 낮은 가격을 저장한다. if(order[i][1] &lt; cost) { cost = order[i][1]; } } } return cost; } } 주절주절너무 옛날에 풀어서 정확히 기억이 안난다. 시간나면 다시 풀어보아야겠다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"}]},{"title":"제7회-대학생-프로그래밍-경시대회-문제-a-letter-bank","slug":"제7회-대학생-프로그래밍-경시대회-문제-a-letter-bank","date":"2014-05-13T16:16:00.000Z","updated":"2017-04-09T03:48:39.904Z","comments":true,"path":"2014/05/14/제7회-대학생-프로그래밍-경시대회-문제-a-letter-bank/","link":"","permalink":"http://sarojaba.github.io/2014/05/14/제7회-대학생-프로그래밍-경시대회-문제-a-letter-bank/","excerpt":"","text":"문제문자 저장소는 새로운 단어를 만들기 위해 여러번(최소한 한번 이상) 사용된 모든 문자들로 구성된 단어이다. 예를들어 IMPS는 MISSISSIPPI의 문자 저장소이다. a 와 b의 두 단어를 입력으로 받고, 당신은 a가 b의 문자 저장소인지 판단하는 프로그램을 작성한다. 첫번째 단어가 (문자들이) 반복된 단어가 아니라고 가정해라. 모든 단어들은 오직 대문자들만 포함한다.(A, B, …, Z, 공백 없음) 입력프로그램은 표준 입력으로부터 입력받는다. 입력은 T(1 ≤ T ≤ 20) 개의 테스트 조건을 갖는다. 테스트 조건의 개수인 T는 입력의 첫번째 줄에 주어진다. 각각의 테스트 조건들은 한줄에 두 단어가 주어진다. 첫번째 단어와 두번째 단어 사이에는 하나의 공백이 존재한다. 그리고 각 단어는 최대 80글자를 가진다. 출력프로그램은 표준 출력으로 출력한다. 각 테스트 조건은 정확히 한줄에 하나씩 출력해라. 각 테스트 조건에 대해, 만약 첫번째 단어가 두번째 단어의 저장소이면 &ldquo;YES&rdquo;, 그렇지 않으면 &ldquo;NO&quot;를 출력해라. 소스코드import java.util.Scanner; public class LetterBank { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int T = scan.nextInt(); // 테스트 케이스 개수 for(int i = 0; i &lt; T; i++) { String a = scan.next(); // 첫번째 단어 String b = scan.next(); // 두번째 단어 process(a, b); } } public static void process(String bank, String word) { if(isBank(bank, word)) { System.out.println(&quot;YES&quot;); } else { System.out.println(&quot;NO&quot;); } } public static boolean isBank(String bank, String word) { boolean[] alpha = new boolean[26]; // word에 나온 글자에 다 체크한다. for(int i = 0 ; i &lt; word.length(); i++) { alpha[word.charAt(i) - &apos;A&apos;] = true; } // bank의 글자에 체크 반전시킨다. for(int i = 0; i &lt; bank.length(); i++) { alpha[bank.charAt(i) - &apos;A&apos;] = !alpha[bank.charAt(i) - &apos;A&apos;]; } // 모두 처음의 값이면 성공한 것이다. for(int i = 0 ; i &lt; alpha.length; i++) { if(alpha[i]) { return false; } } return true; } } 주절주절중복한 문자들을 어떻게 처리할 수 있을까 생각하던중&hellip; 배열을 이용하기로 하였다. 괜찮은 판단이었던 것 같다. ㅋㅋ","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"제4회-대학생-프로그래밍-경시대회-문제-b-벌집","slug":"제4회-대학생-프로그래밍-경시대회-문제-b-벌집","date":"2014-05-13T16:10:00.000Z","updated":"2017-04-09T03:49:29.021Z","comments":true,"path":"2014/05/14/제4회-대학생-프로그래밍-경시대회-문제-b-벌집/","link":"","permalink":"http://sarojaba.github.io/2014/05/14/제4회-대학생-프로그래밍-경시대회-문제-b-벌집/","excerpt":"","text":"Source Codeimport java.util.Scanner; public class Honeycomb { private static final int SIDE = 6; // 벌집 면의 수 public static void main(String[] args) { Scanner scan = new Scanner(System.in); int T = scan.nextInt(); // 테스트 케이스의 개수 for(int i = 0; i &lt; T; i++) { int N = scan.nextInt(); // 방 번호 System.out.println(process(N)); } } public static int process(int N) { int d = 1; // 지나가는 방의 개수 int lev = 0; // 각 레벨의 방의 개수 while(N &gt; 1) { lev += SIDE; N -= lev; d++; } return d; } } Comment곰곰히 생각해보면 수열 문제로 생각할 수 있다. 벌집의 레벨이 늘어날때마다 각 레벨의 방의 개수가 6개씩 늘어난다. 중앙의 방에서부터 차례로 빼나가다보면 답이 나온다. 이 녀석은 나를 고민을 많이하게 만들었지만 재밌는 문제였다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"}]},{"title":"제4회-대학생-프로그래밍-경시대회-문제-a-점수-집계","slug":"제4회-대학생-프로그래밍-경시대회-문제-a-점수-집계","date":"2014-05-11T14:21:00.000Z","updated":"2017-04-09T03:49:43.533Z","comments":true,"path":"2014/05/11/제4회-대학생-프로그래밍-경시대회-문제-a-점수-집계/","link":"","permalink":"http://sarojaba.github.io/2014/05/11/제4회-대학생-프로그래밍-경시대회-문제-a-점수-집계/","excerpt":"","text":"소스코드import java.util.Arrays; import java.util.Scanner; public class Score { private static final int NUM_REFEREE = 5; // 심판의 수 private static final int MAX_GAP = 4; // 최고점과 최저점의 차이 public static void main(String[] args) { Scanner scan = new Scanner(System.in); int T = scan.nextInt(); // 테스트 케이스 개수 int[] N = new int[NUM_REFEREE]; // 다섯 심판이 준 점수 for(int i = 0; i &lt; T; i++) { for(int j = 0; j &lt; N.length; j++) { N[j] = scan.nextInt(); } process(N); } } public static void process(int[] n) { // 정렬한다. Arrays.sort(n); // 최고점과 최저점을 제외한다. // 나머지 최고점과 최저점의 차이가 4점 이상 나면 KIN을 출력하고 // 아니면 총점을 출력한다. if(Math.abs(n[1] - n[3]) &gt;= MAX_GAP) { System.out.println(&quot;KIN&quot;); } else { System.out.println(n[1] + n[2] + n[3]); } } } 주절주절최소값과 최대값은 정렬을 하면 쉽게 구할 수 있다. 다행히 자바에서는 정렬 라이브러리가 있기에 쉽게 풀 수 있었다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"제9회-대학생-프로그래밍-경시대회-문제-e-maze","slug":"제9회-대학생-프로그래밍-경시대회-문제-e-maze","date":"2014-05-11T14:18:00.000Z","updated":"2017-04-09T03:49:59.238Z","comments":true,"path":"2014/05/11/제9회-대학생-프로그래밍-경시대회-문제-e-maze/","link":"","permalink":"http://sarojaba.github.io/2014/05/11/제9회-대학생-프로그래밍-경시대회-문제-e-maze/","excerpt":"","text":"소스코드#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; char** maze; // 미로 int** usedEnergyMaze; // 에너지 사용량 int M, N; // 행, 열 // 재귀적으로 미로 전 영역의 에너지 사용량을 기록한다. void GetUsedEnergy(int row, int col, int energy) { // 미로 밖으로 벗어난 경우 if(row &lt; 0 || col &lt; 0 || row &gt;= M || col &gt;= N) { return; } // 벽을 만나면 에너지 사용량을 증가시킨다. if(maze[row][col] == &apos;*&apos;) { energy++; } // 알려진 에너지 사용량보다 적으면 갱신한다. if(energy &lt; usedEnergyMaze[row][col]) { usedEnergyMaze[row][col] = energy; } else { return; } // 네 방향으로 반복해서 탐색한다. GetUsedEnergy(row - 1, col, energy); GetUsedEnergy(row + 1, col, energy); GetUsedEnergy(row, col - 1, energy); GetUsedEnergy(row, col + 1, energy); } // 해당 에너지량으로 로봇을 구출할 수 있을지 판단한다. bool canRescue(int energy) { // 출발 위치를 구한다. int row, col; for(int i = 0; i &lt; M; i++) { for(int j = 0; j &lt; N; j++) { if(maze[i][j] == &apos;S&apos;) { row = i; col = j; } } } // 미로 전 영역의 에너지 사용량을 구한다. GetUsedEnergy(row, col, 0); // 도착 위치까지의 에너지 사용량이 로봇의 에너지보다 작은지 판단한다. for(int i = 0; i &lt; M; i++) { for(int j = 0; j &lt; N; j++) { if(maze[i][j] == &apos;T&apos;) { if(usedEnergyMaze[i][j] &lt;= energy) { return true; } } } } return false; } int main() { int T; // 테스트 케이스의 개수 cin &gt;&gt; T; for(int i = 0; i &lt; T; i++) { int k; // 로봇의 충전된 에너지 cin &gt;&gt; k; cin &gt;&gt; M &gt;&gt; N; // 미로를 초기화한다. maze = new char*[M]; for(int j = 0; j &lt; M; j++) { maze[j] = new char[N]; } for(int j = 0; j &lt; M; j++) { for(int k = 0; k &lt; N; k++) { cin &gt;&gt; maze[j][k]; } } // 에너지 사용량을 초기화한다. usedEnergyMaze = new int*[M]; for(int j = 0; j &lt; M; j++) { usedEnergyMaze[j] = new int[N]; } int intMax = pow(2, 31) - 1; // 정수의 최대값 for(int j = 0; j &lt; M; j++) { for(int k = 0; k &lt; N; k++) { usedEnergyMaze[j][k] = intMax; } } // 로봇을 구하면 y를 구하고, 아니면 n을 구한다 if(canRescue(k)) { cout &lt;&lt; &apos;y&apos; &lt;&lt; endl; } else { cout &lt;&lt; &apos;n&apos; &lt;&lt; endl; } // 메모리를 해제한다. for(int j = 0; j &lt; M; j++) { delete[] usedEnergyMaze[j]; } delete[] usedEnergyMaze; for(int j = 0; j &lt; M; j++) { delete[] maze[j]; } delete[] maze; } return 0; } 주절주절재귀적인 탐색 문제이다. 4방향으로 탐색하며 각 셀마다 이동하는데 사용되는 최소 에너지량을 구한다. 이미 방문한 셀이라도 더 적은 에너지로 갈 수 있으면 이동해야 한다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"},{"name":"C++","slug":"C","permalink":"http://sarojaba.github.io/tags/C/"}]},{"title":"제9회-대학생-프로그래밍-경시대회-문제-d-노선도","slug":"제9회-대학생-프로그래밍-경시대회-문제-d-노선도","date":"2014-05-11T14:15:00.000Z","updated":"2017-04-09T03:50:24.838Z","comments":true,"path":"2014/05/11/제9회-대학생-프로그래밍-경시대회-문제-d-노선도/","link":"","permalink":"http://sarojaba.github.io/2014/05/11/제9회-대학생-프로그래밍-경시대회-문제-d-노선도/","excerpt":"","text":"Source Code#include &lt;iostream&gt; using namespace std; struct Station { int x; int r; }; bool IsGoodLine(Station* stations, int len) { for(int j = 1; j &lt; len - 1; j++) { int width = stations[j+1].x - stations[j-1].x; if(stations[j].r &gt; width) { return false; } } return true; } int main() { int T; // 테스트 케이스의 개수 cin &gt;&gt; T; for(int i = 0; i &lt; T; i++) { int N; cin &gt;&gt; N; Station* stations = new Station[N]; for(int j = 0; j &lt; N; j++) { cin &gt;&gt; stations[j].x &gt;&gt; stations[j].r; } if(IsGoodLine(stations, N)) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } delete[] stations; } return 0; } Comment생각보다 간단한 문제였네요. 키포인트는 해당 역의 이름표의 길이가 주변 역과의 거리보다 길면 안된다는 사실&hellip;","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"},{"name":"C++","slug":"C","permalink":"http://sarojaba.github.io/tags/C/"}]},{"title":"제3회-대학생-프로그래밍-경시대회-문제-a-수-뒤집기","slug":"제3회-대학생-프로그래밍-경시대회-문제-a-수-뒤집기","date":"2014-05-08T16:37:00.000Z","updated":"2017-04-09T03:50:37.846Z","comments":true,"path":"2014/05/09/제3회-대학생-프로그래밍-경시대회-문제-a-수-뒤집기/","link":"","permalink":"http://sarojaba.github.io/2014/05/09/제3회-대학생-프로그래밍-경시대회-문제-a-수-뒤집기/","excerpt":"","text":"소스코드import java.util.Scanner; public class Reverse { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int T = scan.nextInt();// 테스트 케이스 개수 for(int i = 0; i &lt; T; i++) { int N = scan.nextInt();// 정수 process(N); } } public static void process(int n) { // 원래 수와 뒤집은 수를 합한다. int sum = n + reverse(n); // 합한 수를 뒤집어 비교한다. if(sum == reverse(sum)) { System.out.println(&quot;YES&quot;); } else { System.out.println(&quot;NO&quot;); } } /** * 수를 뒤집는다. ex) 123 -&gt; 321 * * @param num 뒤집을 수 * @return 뒤집힌 수 */ public static int reverse(int num) { int ret = 0; while(num &gt; 0) { // 기존 숫자를 왼쪽 시프트 한다. ret *= 10; // 마지막 한자리를 떼어낸다. double temp = num % 10; num /= 10; ret += temp; } return ret; } } 주절주절Palindrome(회문: 뒤집어도 같은 단어(ex: 별똥별)) 문제이다. 숫자를 문자열로 바꾸어서 처리해도 되지만, 문자로 바꾸지 않고 바로 뒤집어 보았다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"}]},{"title":"제2회-대학생-프로그래밍-온라인대회-문제-a-게시판","slug":"제2회-대학생-프로그래밍-온라인대회-문제-a-게시판","date":"2014-05-08T16:34:00.000Z","updated":"2017-04-09T03:51:09.909Z","comments":true,"path":"2014/05/09/제2회-대학생-프로그래밍-온라인대회-문제-a-게시판/","link":"","permalink":"http://sarojaba.github.io/2014/05/09/제2회-대학생-프로그래밍-온라인대회-문제-a-게시판/","excerpt":"","text":"소스코드import java.util.Scanner; public class Board { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int T = scan.nextInt(); // 테스트 케이스의 개수 for(int i = 0; i &lt; T; i++) { int x1 = scan.nextInt(); int y1 = scan.nextInt(); int x2 = scan.nextInt(); int y2 = scan.nextInt(); int x3 = scan.nextInt(); int y3 = scan.nextInt(); int x4 = scan.nextInt(); int y4 = scan.nextInt(); process(x1, y1, x2, y2, x3, y3, x4, y4); } } public static void process(int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4) { int maxX = Math.max(x1, x3); //int maxX = x1 &gt; x3 ? x1 : x3; int maxY = Math.max(y1, y3); //int maxY = y1 &gt; y3 ? y1 : y3; int minX = Math.min(x2, x4); // int minX = x2 &lt; x4 ? x2 : x4; int minY = Math.min(y2, y4); //int minY = y2 &lt; y4 ? y2 : y4; int area = (x2 - x1) * (y2 - y1) - (minX - maxX) * (minY - maxY); System.out.println(area); } } 주절주절간단한 기하 문제이다. 먼저 붙힌 포스터의 넓이를 구한뒤 나중에 붙힌 포스터와 겹치는 넓이를 빼주면 된다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"}]},{"title":"acm-icpc-2000-asia-problem-a-car-racing","slug":"acm-icpc-2000-asia-problem-a-car-racing","date":"2014-05-06T10:21:00.000Z","updated":"2017-04-09T03:51:24.856Z","comments":true,"path":"2014/05/06/acm-icpc-2000-asia-problem-a-car-racing/","link":"","permalink":"http://sarojaba.github.io/2014/05/06/acm-icpc-2000-asia-problem-a-car-racing/","excerpt":"","text":"Source Codeimport java.util.Arrays; import java.util.Scanner; public class CarRacing { public static void main(String[] args) { Scanner scan = new Scanner(System.in); int T = scan.nextInt(); // 테스트 케이스의 개수 for (int i = 0; i &lt; T; i++) { int N = scan.nextInt(); // 자동차의 개수 int[] cars = new int[N]; // 자동차 번호 배열 for (int j = 0; j &lt; N; j++) { cars[j] = scan.nextInt(); } process(cars); } } public static void process(int[] cars) { // 바로 들어갈 수 있는 차들은 보내고 나머지만 남긴다. int i = 0; while(cars[i] == (i + 1)) { i++; } cars = Arrays.copyOfRange(cars, i, cars.length); // 다음으로 들어가야할 차의 위치를 구한다. int index = getIndexOfMinValue(cars); // 그 녀석보다 앞의 차들은 바이패스로... // 그 녀석보다 뒤의 차들은 원래 라인으로... int[] bypass = Arrays.copyOfRange(cars, i, index); int[] original = Arrays.copyOfRange(cars, index + 1, cars.length); // 두 라인에서 순서대로 들어갈 수 있으면 YES // 아니라면 NO를 출력한다. if (isSorted(bypass) &amp;&amp; isSorted(original)) { System.out.println(&quot;YES&quot;); } else { System.out.println(&quot;NO&quot;); } } /** * 배열에서 최소값의 위치를 구한다. * @param numbers 배열 * @return 최소값의 위치 */ public static int getIndexOfMinValue(int[] numbers) { int min = numbers[0]; int index = 0; for (int i = 1; i &lt; numbers.length; i++) { if (numbers[i] &lt; min) { min = numbers[i]; index = i; } } return index; } /** * 오름차순으로 정렬되어 있는지 판단한다. * @param numbers 정수 배열 * @return 오름차순으로 정렬되어 있으면 YES, 아니면 NO */ public static boolean isSorted(int[] numbers) { for (int i = 0; i &lt; numbers.length - 1; i++) { if (numbers[i] &gt; numbers[i + 1]) { return false; } } return true; } } Comment문제를 잘못 이해해 bypass에 차가 한 대만 들어간다고 생각해버렸다. 다시 수정하여 풀었다. 정렬을 이용하여 풀어보았다. 하지만 Queue를 이용해서 풀면 좋을 듯한 문제인듯 ㅋㅋ","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"}]},{"title":"acm-icpc-2000-asia-practice-problem-b-cross-a","slug":"acm-icpc-2000-asia-practice-problem-b-cross-a","date":"2014-05-06T08:35:00.000Z","updated":"2017-04-09T03:51:40.248Z","comments":true,"path":"2014/05/06/acm-icpc-2000-asia-practice-problem-b-cross-a/","link":"","permalink":"http://sarojaba.github.io/2014/05/06/acm-icpc-2000-asia-practice-problem-b-cross-a/","excerpt":"","text":"Source Codeimport java.util.Scanner; public class CrossCreek{ public static void main(String[] args){ Scanner scan = new Scanner(System.in); int t = scan.nextInt(); // 테스트 케이스 개수 for(int i = 0; i &lt; t; i++) { int n = scan.nextInt(); // 개울의 너비 process(n); } } public static void process(int n) { // 모든 경우를 구한다. long sum = 0; for(long i = n, r = 0; i &gt;= r; i--, r++){ sum += combination(i, r); } System.out.println(sum); } // 팩토리얼을 구한다. // n! = n * (n-1) * (n-2) * ... * 2 * 1 // ex) 4! = 4 * 3 * 2 * 1 = 24 public static long factorial(long n){ if(n &lt;= 1){ return 1; } return n * factorial(n - 1); } // 조합을 구한다. // nCr = nPr / r! = n! / ((n-r)! * r!) // ex) 4개 중에 2개를 고르는 경우의 수 = 6가지 public static long combination(long n, long r){ return factorial(n) / (factorial(n - r) * factorial(r)); } } Comment문제를 보고 고민을 하다가 조합으로도 풀 수 있단것을 알게되었다. 수학책을 찾아보고 조합 공식에 맞춰 함수를 작성하였다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"ICPC","slug":"ICPC","permalink":"http://sarojaba.github.io/tags/ICPC/"}]},{"title":"제2회-대학생-프로그래밍-온라인대회-연습문제-b-테이블-정리","slug":"제2회-대학생-프로그래밍-온라인대회-연습문제-b-테이블-정리","date":"2014-05-01T15:34:00.000Z","updated":"2017-04-09T03:52:18.818Z","comments":true,"path":"2014/05/02/제2회-대학생-프로그래밍-온라인대회-연습문제-b-테이블-정리/","link":"","permalink":"http://sarojaba.github.io/2014/05/02/제2회-대학생-프로그래밍-온라인대회-연습문제-b-테이블-정리/","excerpt":"","text":"문제소스코드#include &lt;iostream&gt; using namespace std; int tables[4][4]; // 테이블 상태 int Move(int, int); int main() { int T; cin &gt;&gt; T; // 테스트 케이스의 개수 for(int i = 0; i &lt; T; i++) { int sum = 0; for(int j = 0; j &lt; 4; j++) { for(int k = 0; k &lt; 4; k++) { cin &gt;&gt; tables[j][k]; sum += tables[j][k]; } } cout &lt;&lt; sum - Move(0, 0) &lt;&lt; endl; } return 0; } int Move(int col, int flag) { if(col &gt;= 4) { return 0; } int max = 0; for(int i = 0; i &lt; 4; i++) { if(flag &amp; (1 &lt;&lt; i)) { continue; } int val = tables[i][col] + Move(col + 1, flag | (1 &lt;&lt; i)); if(val &gt; max) { max = val; } } return max; } 코멘트실수로 배열에 행과 열을 반대로 저장해 푸는데 오래걸렸다. 가장 적게 이동한 인원을 찾는것과 전체 인원에서 이동안한 인원을 제외한 인원이 같기에 후자로 구하였다. 재귀적으로 백트래킹을 수행하였다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"제2회-대학생-프로그래밍-온라인대회-연습문제-a-소수-판정","slug":"제2회-대학생-프로그래밍-온라인대회-연습문제-a-소수-판정","date":"2014-05-01T15:26:00.000Z","updated":"2017-04-09T03:54:06.759Z","comments":true,"path":"2014/05/02/제2회-대학생-프로그래밍-온라인대회-연습문제-a-소수-판정/","link":"","permalink":"http://sarojaba.github.io/2014/05/02/제2회-대학생-프로그래밍-온라인대회-연습문제-a-소수-판정/","excerpt":"","text":"문제소스 코드#include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; bool IsPrime(int); int main() { int T;// 테스트 케이스 개수(1 &lt;= T &lt;= 10) cin &gt;&gt; T; for(int i = 0; i &lt; T; i++) { int N;// 소수인지 판정할 자연수(1 &lt;= N &lt;= 100,000,000) cin &gt;&gt; N; if(IsPrime(N)) { cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; } } return 0; } bool IsPrime(int n) { for(int i = 2; i &lt; sqrt(n); i++) { if(n % i == 0) { return false; } } return true; } 코멘트소수를 구하는 문제이다. 이 문제의 키 포인트는 제곱근 이상은 해볼 필요가 없다는 사실인것 같다.","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"C++","slug":"C","permalink":"http://sarojaba.github.io/tags/C/"}]},{"title":"visual-studio-에서-컴파일시-계속-프로세스-잡고-있는-문제-해결-방법","slug":"visual-studio-에서-컴파일시-계속-프로세스-잡고-있는-문제-해결-방법","date":"2014-04-30T13:30:00.000Z","updated":"2017-04-09T03:54:21.103Z","comments":true,"path":"2014/04/30/visual-studio-에서-컴파일시-계속-프로세스-잡고-있는-문제-해결-방법/","link":"","permalink":"http://sarojaba.github.io/2014/04/30/visual-studio-에서-컴파일시-계속-프로세스-잡고-있는-문제-해결-방법/","excerpt":"","text":"구글링과 MSDN을 뒤져본 결과&hellip; 보통 Windows 7 에서 발생한다고 하는데&hellip; 다른 프로세스가 컴파일시 생성되는 임시파일에 계속 접근하고 있어서 컴파일러가 파일에 접근하지 못한다고 하네요. 곰곰히 생각해본 결과 가장 가능성 있는것은 백신의 실시간 감시 기능&hellip; 즉, 백신의 실시간 감시 기능을 꺼두면 아무 문제없이 빌드가 됩니다. ㅎㅎㅎ","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"http://sarojaba.github.io/tags/Visual-Studio/"}]},{"title":"히스토그램을-이용한-영상처리-프로그램","slug":"히스토그램을-이용한-영상처리-프로그램","date":"2014-04-30T13:20:00.000Z","updated":"2017-04-09T03:54:49.498Z","comments":true,"path":"2014/04/30/히스토그램을-이용한-영상처리-프로그램/","link":"","permalink":"http://sarojaba.github.io/2014/04/30/히스토그램을-이용한-영상처리-프로그램/","excerpt":"","text":"히스토그램 평활화 기본 명암 대비 스트레칭 엔드인 명암 대비 스트레칭 역 변환 감마 변환","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Image Processing","slug":"Image-Processing","permalink":"http://sarojaba.github.io/tags/Image-Processing/"},{"name":"Histogram","slug":"Histogram","permalink":"http://sarojaba.github.io/tags/Histogram/"}]},{"title":"컬러모델-변환-프로그램","slug":"컬러모델-변환-프로그램","date":"2014-04-30T13:15:00.000Z","updated":"2017-04-09T03:56:17.481Z","comments":true,"path":"2014/04/30/컬러모델-변환-프로그램/","link":"","permalink":"http://sarojaba.github.io/2014/04/30/컬러모델-변환-프로그램/","excerpt":"","text":"RGB를 Gray Level로 변환한다. RGB를 CMY로 변환한다. RGB를 HSI로 변환한다. HSI를 RGB로 변환한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Image Processing","slug":"Image-Processing","permalink":"http://sarojaba.github.io/tags/Image-Processing/"}]},{"title":"twoword-index","slug":"twoword-index","date":"2014-04-29T15:15:00.000Z","updated":"2017-04-09T03:58:16.212Z","comments":true,"path":"2014/04/30/twoword-index/","link":"","permalink":"http://sarojaba.github.io/2014/04/30/twoword-index/","excerpt":"","text":"프로그램 구조 UserInterface 인터페이스UI의 공통적인 기능을 묶어서 인터페이스로 선언하였다. UI의 변경을 쉽게 해줄 수 있는 장점이 있다. 입력은 input 메소드, 출력은 output 메소드, 종료는 close 메소드로 선언하였다. Console 클래스콘솔 환경에서의 UI를 정의하였다. UserInterface 인터페이스의 메소드들을 구현하고 있다. Scanner 클래스를 이용하여 콘솔에서 파일명과 횟수를 입력받도록 하였다. GUI 클래스그래픽 환경에서의 UI를 정의하였다. JFileDialog 클래스를 이용해 파일 입력을 쉽게 받도록 하였다. display 메소드는 기본적인 파일 생성 뿐만 아니라 화면상에 JTree 클래스를 이용해 트리 구조를 표시하여 인덱스 구조를 더욱 명확하게 알 수 있도록 하였다. TwoWordIndex 클래스이 프로그램의 핵심적 클래스이다. 키워드의 인덱스 구조를 정의 및 다루는 메소드들을 포함하고 있다. addKeyWords 메소드는 키워드 목록을 작성하는 메소드이고, removeUnderCount 메소드는 최소 출현 횟수 이하의 키워드는 삭제하는 메소드이다. sort 메소드는 정렬을 하는 기능을, display 메소드는 파일에 출력하는 기능을 담당하고 있다. Word 클래스Prefix와 Suffix의 공통적 속성인 문자열(단어)을 추상 클래스로 묶었다. compareTo 메소드를 구현하여 정렬을 손쉽게 할 수 있도록 하였다. Prefix 클래스키워드의 앞 단어를 정의하는 클래스이다. 멤버로 Suffix들의 리스트를 가지고 있다. 리스트는 Iterator 인터페이스를 이용해 탐색을 하였다. Suffix 클래스키워드의 뒷 단어를 정의하는 클래스이다. 멤버로 줄 번호를 리스트로 가지고 있다. 줄 번호의 개수는 키워드의 출현 횟수를 뜻한다. 프로그램 실행 예 입력 원문 텍스트 An array of controversial topics, including a proposal to declare the border area a war-free zone, is being discussed ahead of the Oct.2-4 summit between President Roh Moo-hyun and North Korean leader Kim Jong-il. The summit, the second of its kind, is expected to focus mostly on topics for promoting peninsular peace and, more importantly, those confirming Seoul&rsquo;s engagement policy toward Pyongyang. Toward that goal, the government has been considering the extent to which it would discuss nuclear programs with North Korea. Earlier this month, Roh told reporters that, because &ldquo;the North has already shown it will readily commit to denuclearization, there will be no need to aggravate them by mentioning the programs in the summit.&rdquo; The president cited the six-party talks and the latest progress in inspecting and shutting down North Korea&rsquo;s nuclear facilities as evidence of the communist regime&rsquo;s renewed commitment. However, the president&rsquo;s chief security adviser recently said that North Korea&rsquo;s denuclearization would inevitably be on the agenda since the whole idea of the summit is to pursue peninsular peace and to promote inter-Korean exchanges. Yesterday, the government said that the two Koreas may discuss establishing a joint committee to cooperate in reducing conventional weapons. &ldquo;We probably would not see immediate results, but such a committee could be meaningful, in that we would open a channel of dialogue with the North on the issue of conventional weapons,&rdquo; said Kim Jin-moo, a researcher at the Korea Institute for Defense Analyses. North Korea is estimated to have about twice the number of conventional weapons that the South has, but how formidable the North Korean army is minus nuclear weapons is disputed. Other contentious issues mentioned so far include whether the government would propose the Demilitarized Zone and the Northern Limit Line as &ldquo;peace zones.&rdquo; Contrary to its name, the DMZ is a heavily armed buffer zone, while the NLL is a de-factor border where numerous inter-Korean naval battles - some bloody - have erupted. The conservative Grand National Party has been reiterating its objection to such peace zones, saying that they would undermine the country&rsquo;s security. The GNP is also adamant that Seoul discuss and review Pyongyang&rsquo;s plans for denuclearization. Further, the Roh administration may attempt to persuade the North to agree to a peace declaration now, seven years after former president Kim Dae-jung failed, analysts say. In 2000, Pyongyang refused to sign onto such a declaration. On the economic front, the government is likely to suggest building more industrial facilities similar to the Gaeseong Industrial Complex where South Korean companies employ North Koreans. Candidate sites for the second and third complexes are the Haeju or Nampo areas in the North. &ldquo;Considering that we are fast heading toward an inter-Korean economic community of some kind, increasing the number of industrial complexes appears to be the way to go,&rdquo; said Baek Jong-chun, Roh&rsquo;s top security adviser. Experts have recommended making more roads and train lines between the two Koreas. Earlier, the president said he does not expect to reap significant results from the meeting with Kim. He explained that he does not want to burden the people or the next administration by trying to push fresh deals with the North. The conservatives have argued that Roh&rsquo;s attitude belies how he is seeking to use the inter-Korean summit as political leverage for the nation&rsquo;s liberals as they struggle to compete against the GNP&rsquo;s Lee Myung-bak, the most popular candidate so far in the run-up to the December presidential election. By Kim Ji-hyun 금지어 목록 텍스트 a an the he it our she that them they we are be been can do does has have is may must shall should was will would about behind by for in of on onto to also and as but no not or so such yes how what when where who why 0 1 2 3 4 5 6 7 8 9 ! &ldquo; # $ % &amp; &rsquo; ( ) * + , - . / : ; &lt; = &gt; ? @ [ \\ ] ^ _ ` { | } ~ 키워드 최소 출현 횟수2 출력된 파일 conventional weapons [11, 13, 15] North Korea [5, 7, 9, 15] North Korean [1, 15] peace zones [17, 19] peninsular peace [3, 9] security adviser [9, 31] two Koreas [11, 33] 본 과제를 하면서 느낀 점본 과제를 하면서 느낀 가장 큰 어려움은 텍스트를 파싱하는 것이었다. 처음엔 텍스트를 토큰 단위로 나누는 것에만 집착한 나머지 글자와 마침표가 붙어있는 것들을 나누려고 하니 코드가 많이 지저분해졌다. 결국엔 정규표현식을 이용해 매칭된 단어나 기호들을 찾아내는 것으로 아이디어를 돌리니 아주 간단해졌다. 또, 제네릭이나 오토박싱/언박싱, foreach구문 등을 상당 부분 사용했다. 하위호환성과 편리함을 놓고 잠시 고민을 했지만 새로운 기능에 손을 들어주었다. 마지막으로, 교수님이 말씀하신 미학적인 프로그램을 위해 고민을 했음에도 불구하고 단점이 눈에 많이 보인다. 하지만 자료구조에 대한 많은 공부를 할 수 있었고 배열과 리스트에 대해 더욱 깊게 이해할 수 있었다. 개인적인 생각으로는 자바의 ArrayList 클래스를 이용하는 것도 좋지만 복습의 측면에서 각자 ArrayList를 구현하고 그것으로 이 과제를 수행하는 것도 나쁘진 않을듯 하다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"opengl을-이용한-지구본-텍스쳐-매핑","slug":"opengl을-이용한-지구본-텍스쳐-매핑","date":"2014-04-29T14:59:00.000Z","updated":"2017-04-09T03:58:43.376Z","comments":true,"path":"2014/04/29/opengl을-이용한-지구본-텍스쳐-매핑/","link":"","permalink":"http://sarojaba.github.io/2014/04/29/opengl을-이용한-지구본-텍스쳐-매핑/","excerpt":"","text":"내용 설명 체크보드 패턴의 3차원 평면을 그린다. 세계 지도 그림을 텍스쳐 매핑한 정육면체를 그린다. 세계 지도를 매핑한 지구본을 그린다. 마우스를 드래그해 원하는 각도로 회전할 수 있다. 출력 화면GL_DECAL GL_MODULATE","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-3d-랜더링-및-애니메이션","slug":"opengl을-이용한-3d-랜더링-및-애니메이션","date":"2014-04-29T14:53:00.000Z","updated":"2017-04-09T04:00:28.312Z","comments":true,"path":"2014/04/29/opengl을-이용한-3d-랜더링-및-애니메이션/","link":"","permalink":"http://sarojaba.github.io/2014/04/29/opengl을-이용한-3d-랜더링-및-애니메이션/","excerpt":"","text":"내용 설명 사용자의 입력에 따라 3차원 객체의 렌더링을 변경하는 애니메이션 프로그램 이십면체는 원점에 위치시키고 Y축으로 회전, 스페이스 키를 누르면 쉐이드 모드가 바뀜 정육면체는 원점에 위치시키고 Y축으로 회전 작은 구는 정육면체의 꼭지점에 위치 큰 구는 정육면체의 뒤에 위치하고 자신의 Y축으로 회전 출력 화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-3d-로봇-그리기","slug":"opengl을-이용한-3d-로봇-그리기","date":"2014-04-28T14:37:00.000Z","updated":"2017-04-09T04:00:45.528Z","comments":true,"path":"2014/04/28/opengl을-이용한-3d-로봇-그리기/","link":"","permalink":"http://sarojaba.github.io/2014/04/28/opengl을-이용한-3d-로봇-그리기/","excerpt":"","text":"내용 설명 각 부위가 위치할 곳으로 이동한다. 적당한 크기로 변환을 한다. 정육면체를 그려 부위를 만든다. 1~3을 반복해 로봇을 완성한다. 출력 화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-2d-삼각형-변환","slug":"opengl을-이용한-2d-삼각형-변환","date":"2014-04-28T14:34:00.000Z","updated":"2017-04-09T04:01:14.236Z","comments":true,"path":"2014/04/28/opengl을-이용한-2d-삼각형-변환/","link":"","permalink":"http://sarojaba.github.io/2014/04/28/opengl을-이용한-2d-삼각형-변환/","excerpt":"","text":"내용설명해바라기 모양 원하는 각도로 회전한다. y축으로 이동시킨다. 삼각형을 그린다. 1~3를 반복하여 그림을 완성한다. 강강 수월래 모양 원하는 각도로 회전한다. x축으로 이동시킨다. 삼각형을 그린다. 1~3를 반복하여 그림을 완성한다. 불꽃 모양 원하는 각도로 회전한다. x축으로 이동시킨다. 삼각형을 그린다. 반대방향으로 각도만큼 회전한다. 1~4를 반복하여 그림을 완성한다. 결과화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-polyspirals-그리기","slug":"opengl을-이용한-polyspirals-그리기","date":"2014-04-20T05:09:00.000Z","updated":"2017-04-09T04:01:51.988Z","comments":true,"path":"2014/04/20/opengl을-이용한-polyspirals-그리기/","link":"","permalink":"http://sarojaba.github.io/2014/04/20/opengl을-이용한-polyspirals-그리기/","excerpt":"","text":"육각형60도씩 돌고, 이동거리는 100에서 1씩 감소함. 바람개비89.5도씩 돌고, 이동거리는 200에서 1씩 감소함. 별-144도씩 돌고, 이동거리는 200에서 2씩 감소함. 성게170도씩 돌고, 이동거리는 200에서 2씩 감소함. 오리179도씩 돌고, 이동거리는 200에서 1씩 감소함. 장미100도씩 돌고, 이동거리는 200에서 4씩 감소함.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-지형-그리기","slug":"opengl을-이용한-지형-그리기","date":"2014-04-20T05:03:00.000Z","updated":"2017-04-09T04:02:07.712Z","comments":true,"path":"2014/04/20/opengl을-이용한-지형-그리기/","link":"","permalink":"http://sarojaba.github.io/2014/04/20/opengl을-이용한-지형-그리기/","excerpt":"","text":"내용설명 노을진 밤하늘을 표현하기 위해 화면 크기로 폴리곤을 쉐이드 모드로 그린다. 랜덤한 좌표에 점을 찍어 별을 그린다. 두 개의 원을 이용해 그 사이를 폴리곤으로 채워 달을 그린다. 프랙탈을 이용해 재귀적으로 지형의 좌표를 구하고 내부를 폴리곤으로 채운다. 출력화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-학교-로고-그리기","slug":"opengl을-이용한-학교-로고-그리기","date":"2014-04-18T16:17:00.000Z","updated":"2017-04-09T04:02:22.376Z","comments":true,"path":"2014/04/19/opengl을-이용한-학교-로고-그리기/","link":"","permalink":"http://sarojaba.github.io/2014/04/19/opengl을-이용한-학교-로고-그리기/","excerpt":"","text":"내용 설명 왼쪽 반원을 그리고 그 위에 중점을 오른쪽으로 조금 옮겨 반지름을 조금 늘려 흰색 반원을 덮어 남색 초승달 모양을 만든다. 1번과 대칭되게(중점을 왼쪽으로 옮겨) 오른쪽 하늘색 초승달 모양을 만든다. 0,0을 중점으로 대칭되게 하늘색, 남색 반원을 그린다. 0,0을 중심으로 동일한 너비와 높이의 직각 삼각형을 로고에 맞는 색상으로 그린다. 출력 화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"OpenGL","slug":"OpenGL","permalink":"http://sarojaba.github.io/tags/OpenGL/"}]},{"title":"opengl을-이용한-이름-쓰기","slug":"opengl을-이용한-이름-쓰기","date":"2014-04-18T16:02:00.000Z","updated":"2017-04-09T04:04:24.904Z","comments":true,"path":"2014/04/19/opengl을-이용한-이름-쓰기/","link":"","permalink":"http://sarojaba.github.io/2014/04/19/opengl을-이용한-이름-쓰기/","excerpt":"","text":"내용 설명 각 획은 직선을 그려서 표현한다. 동그라미는 원을 그려서 표현한다. 출력화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"baby-hoola","slug":"baby-hoola","date":"2014-04-18T15:36:00.000Z","updated":"2017-04-09T04:05:04.844Z","comments":true,"path":"2014/04/19/baby-hoola/","link":"","permalink":"http://sarojaba.github.io/2014/04/19/baby-hoola/","excerpt":"","text":"프로그램 구조 Card 클래스게임에서 사용되는 카드를 클래스로 만든 것이다. 카드의 숫자는 A~K까지이고, 무늬는 4가지로 불변의 값이기 때문에 타입에 안전한 enum 키워드를 이용하여 속성값을 정의하였다. 그리고 적절하지 않을지 모르겠지만 GUI 구현시 데이터와 화면표시가 따로 노는 것을 방지하기 위해 JButton 클래스를 상속하여 실제 카드의 데이터와 화면에 보이는 버튼이 한 몸이 되도록 하였다. Player 클래스에서 카드를 순서대로 정렬하기 위해 Comparable 인터페이스를 구현하였다. Deck 클래스52장의 카드 한 벌을 Deck 이라고 한다. 초기엔 카드를 저장하기 위해 Stack 클래스를 사용하여 구현하였다. 하지만 API 문서에서 Deque 인터페이스를 활용하는 것을 권장하기에 이를 따르기로 했다. 이 클래스의 기능 중에 카드를 섞는 shuffle 메소드를 손쉽게 구현하기 위해 Collections 클래스의 shuffle 메소드를 이용하였고 이 메소드는 인자로 List 인터페이스를 구현한 객체를 필요로 하기 때문에 Deque와 List를 둘다 구현하고 있는 LinkedList 클래스를 사용하였다. Player 클래스게임에서 유저나 컴퓨터와 같은 플레이어를 정의한 클래스이다. 컴퓨터와 유저의 공통적인 특성들을 모아놓았고 거의 대부분이 구현되어 있다. abstract 키워드로 하위 클래스에서 객체를 생성하도록 유도하였다. Sort 기능도 Collections 클래스의 Sort 메소드를 이용해 손쉽게 구현하였다. HumanPlayer 클래스유저를 정의하는 클래스이다. 생성자 파라미터로 유저의 이름을 넣을 수 있고 버릴 카드를 직접 선택할 수 있다. ComputerPlayer 클래스게임상의 컴퓨터를 정의하는 클래스이다. 유저와는 반대로 이름과 버릴 카드를 선택할 수 없다. UserInterface 인터페이스UI를 쉽게 변경할 수 있도록 인터페이스를 정의하였다. 나중에 프로그램을 확장해 자신만의 UI를 만들더라도 쉽게 만들 수 있을 것이다. BabyHoolaConsole 클래스위의 클래스들을 이용해 Console 환경으로 구현하였다. GUI 환경을 만들기 전에 테스트 용도로 만들었고 UserInterface 인터페이스를 구현해 UI를 손쉽게 바꿀수 있도록 하였다. BabyHoolaGUI 클래스위의 클래스들을 이용해 GUI 환경으로 구현하였다. 보드 게임의 형식을 갖추고 직관적인 인터페이스를 유지하려고 노력하였다. UserInterface 인터페이스를 구현하였다. 프로그램 실행환경 펜티엄4 2.4Ghz, 메모리 1G 윈도우즈 XP, JRE 1.6 결과화면콘솔 환경 이름 입력 초기 화면 게임 도중 승리시 화면","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"단일-패스-매크로-프로세서","slug":"단일-패스-매크로-프로세서","date":"2014-04-17T15:22:00.000Z","updated":"2017-04-09T04:05:41.676Z","comments":true,"path":"2014/04/18/단일-패스-매크로-프로세서/","link":"","permalink":"http://sarojaba.github.io/2014/04/18/단일-패스-매크로-프로세서/","excerpt":"","text":"과제 목표단일 패스 매크로 프로세서를 구현 프로그램 설명텍스트 파일을 입력으로 받아 매크로 구문을 해석 후 확장된 코드로 변환시켜주는 단일 패스 매크로 프로세서를 자바로 구현함. 입력 텍스트L MACRO ADD1 &amp;A L &amp;A A &amp;A ST &amp;A MEND L MACRO ADDS &amp;A1, &amp;A2, &amp;A3 ADD1 &amp;A1 ADD1 &amp;A2 ADD1 &amp;A3 MEND ADDS DATA1, DATA2, DATA3 END 출력 결과물","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"java로-작성한-도서관리-프로그램","slug":"java로-작성한-도서관리-프로그램","date":"2014-04-17T14:57:00.000Z","updated":"2017-04-09T04:06:40.672Z","comments":true,"path":"2014/04/17/java로-작성한-도서관리-프로그램/","link":"","permalink":"http://sarojaba.github.io/2014/04/17/java로-작성한-도서관리-프로그램/","excerpt":"","text":"프로그램 주제자바를 이용한 통합 도서관리 프로그램 개발목적도서관 관리자에게 관리를 더욱 효율적이고 용이하게 할 수 있도록 도움을 줌. 특징 그래픽 인터페이스를 최대한 직관적이고 쉽도록 구성하였고, 관리자가 실시간으로 모니터링 할 수 있도록 구성하였음. 데이터의 저장과 열기시 파일을 선택할 수 있어 한 프로그램으로 여러 도서관을 관리할 수 있음. 도서 예약 기능을 추가하여 선택한 도서가 이미 대여시 예약이 가능. 반납시 자동으로 대출가능. 개발환경 Pentium4 2GHz, 1GB RAM, WINDOWS XP J2SE SDK 5.0, Eclipse 3.2 프로그램 설명 좌측 상단의 패널에서 학번, 성명, 연락처 등을 입력후 등록 버튼을 눌러 회원을 추가할 수 있음. 또한 우측 상단의 패널에서 번호와 제목을 입력후 등록 버튼을 눌러 도서를 추가할 수 있음. 툴바의 불러오기 버튼을 눌러 데이터가 저장된 파일을 불러옴. 파일명과 확장자는 임의로 지정할 수 있으나 본 예제에서는 list.dat 파일을 사용하겠음. 마찬가지로 저장도 파일 대화창을 띄움. 하단의 대여목록과 예약목록도 같이 불러옴(본 예제는 처음 사용자를 위함). 올바른 데이터가 들어있지 않은 임의의 파일을 불러왔을 경우 에러메시지 대화창을 띄움. 손님의 경우나 대여가 불가능한 장르의 경우 대여 불가능 메시지를 띄움. 참고로 각 목록의 항목을 클릭하면 그에 맞는 속성값들이 출력됨. 예로 대여목록의 경우 대여일자와 반납기한이 출력됨. 이미 대여된 도서의 경우 예약 기능을 이용할 수 있음. 단, 대여가 불가능한 회원이나 장르는 예약도 불가능함. 도서관 이용시간이 끝났을 경우 데이터를 저장해 다음 개장시 다시 불러올 수 있음. 회원목록, 도서목록, 대여목록, 예약목록이 저장됨. 어려웠던 부분 설계 경험 부족으로 인해 초기 기획부터 코딩까지 몇 번이나 다시 시작함. 짧은 테스트 기간으로 인해 찾지 못한 버그의 존재가 의심됨. GUI를 씌우면서 점점 불어나는 소스코드로 인한 클래스 단위의 적절한 분배의 어려움. 향후 개선 사항 리스트의 정렬 및 검색 기능 추가 관리자의 패스워드 잠금 기능 로그 파일을 남겨 월말 결산, 우수 대여자 선발 등에 이용 지저분한 소스코드를 디자인패턴을 통해 리펙토링(Manager 클래스는 Singleton 패턴, GUI 컴포넌트들은 Factory Method 패턴 적용 예상) 배운 점 프로그램 개발과정을 몸으로 느껴볼 수 있는 좋은 기회였음. 개발 초기에 Edit Plus 와 같은 텍스트 에디터를 이용하였으나 점점 규모가 커지면서 Eclipse와 같은 IDE의 필요성을 느끼게 되었음. Eclipse의 기능을 좀 더 알게되었음.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"알고리즘-아트","slug":"알고리즘-아트","date":"2013-10-30T14:25:00.000Z","updated":"2017-04-09T04:06:56.444Z","comments":true,"path":"2013/10/30/알고리즘-아트/","link":"","permalink":"http://sarojaba.github.io/2013/10/30/알고리즘-아트/","excerpt":"","text":"어디서 본 그림인데 기억이 안난다. void setup() { size(500, 500); background(255); smooth(); noFill(); noLoop(); ellipseMode(RADIUS); } void draw() { rule1(width / 2, height / 2, 400); blend(createCircleMask(200), 0, 0, width, height, 0, 0, width, height, ADD); } void rule1(float x, float y, float r) { if (r < 25) { return; } strokeWeight(r / 100); ellipse(x, y, r, r); float hr = r / 2; rule1(x, y, hr); for (int t = 30; t < 360 + 30; t += 60) { float c = hr * cos(radians(t)); float s = hr * sin(radians(t)); rule1(x + c, y + s, hr); } } PGraphics createCircleMask(float r) { PGraphics mask = createGraphics(width, height); mask.beginDraw(); mask.background(255); mask.noStroke(); mask.fill(0); mask.ellipseMode(RADIUS); mask.ellipse(width / 2, height / 2, r, r); mask.endDraw(); return mask; } void setup() { size(500, 500); background(255); smooth(); noFill(); noLoop(); ellipseMode(RADIUS); } void draw() { rule1(width / 2, height / 2, 400); blend(createCircleMask(200), 0, 0, width, height, 0, 0, width, height, ADD); } void rule1(float x, float y, float r) { if (r &lt; 25) { return; } strokeWeight(r / 100); ellipse(x, y, r, r); float hr = r / 2; rule1(x, y, hr); for (int t = 30; t &lt; 360 + 30; t += 60) { float c = hr * cos(radians(t)); float s = hr * sin(radians(t)); rule1(x + c, y + s, hr); } } PGraphics createCircleMask(float r) { PGraphics mask = createGraphics(width, height); mask.beginDraw(); mask.background(255); mask.noStroke(); mask.fill(0); mask.ellipseMode(RADIUS); mask.ellipse(width / 2, height / 2, r, r); mask.endDraw(); return mask; }","categories":[],"tags":[{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"}]},{"title":"코딩을-지탱하는-기술","slug":"코딩을-지탱하는-기술","date":"2013-10-27T11:33:00.000Z","updated":"2017-04-09T04:09:51.337Z","comments":true,"path":"2013/10/27/코딩을-지탱하는-기술/","link":"","permalink":"http://sarojaba.github.io/2013/10/27/코딩을-지탱하는-기술/","excerpt":"","text":"역사와 비교를 통해 프로그래밍 언어의 기본 원리를 정리한 책이다. 지금껏 프로그래밍 언어를 공부하면서 ‘왜’라는 질문을 품어본 적이 없는데, 이 책이 그 ‘왜’라는 질문과 동시에 그 답을 알려줬다. 프로그래머라면 꼭 한번은 읽어야 하는 책이라고 생각한다. 자세한 내용은 책 소개에서 확인하자.","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"http://sarojaba.github.io/tags/Book/"},{"name":"코딩을 지탱하는 기술","slug":"코딩을-지탱하는-기술","permalink":"http://sarojaba.github.io/tags/코딩을-지탱하는-기술/"}]},{"title":"화이","slug":"화이","date":"2013-10-13T14:13:00.000Z","updated":"2017-04-09T04:10:18.776Z","comments":true,"path":"2013/10/13/화이/","link":"","permalink":"http://sarojaba.github.io/2013/10/13/화이/","excerpt":"","text":"5명의 범죄자로부터 길러진 &lsquo;화이’가 괴물이 되어가는 이야기이다. 모든 배우들의 캐릭터가 각각의 색을 가지고 있다. 2~3번은 봐야 전체 스토리를 정확히 해석할 수 있을 듯하다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"화이","slug":"화이","permalink":"http://sarojaba.github.io/tags/화이/"},{"name":"여진구","slug":"여진구","permalink":"http://sarojaba.github.io/tags/여진구/"},{"name":"김윤석","slug":"김윤석","permalink":"http://sarojaba.github.io/tags/김윤석/"}]},{"title":"감시자들","slug":"감시자들","date":"2013-10-09T17:45:00.000Z","updated":"2017-04-09T04:10:38.307Z","comments":true,"path":"2013/10/10/감시자들/","link":"","permalink":"http://sarojaba.github.io/2013/10/10/감시자들/","excerpt":"","text":"용의자들을 감시하는 경찰들의 이야기를 액션감있게 그린 영화이다. 주연 배우(설경구, 한효주, 정우성)들의 사실적인 연기가 극의 재미를 더해준다. 반전에 길들여진 나에게 결말이 약하게 느껴지는건, 마치 조미료에 길들여져 음식 맛을 못느끼게 된 것은 아닐까?","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"감시자들","slug":"감시자들","permalink":"http://sarojaba.github.io/tags/감시자들/"},{"name":"설경구","slug":"설경구","permalink":"http://sarojaba.github.io/tags/설경구/"},{"name":"한효주","slug":"한효주","permalink":"http://sarojaba.github.io/tags/한효주/"},{"name":"정우성","slug":"정우성","permalink":"http://sarojaba.github.io/tags/정우성/"}]},{"title":"bling-ring","slug":"bling-ring","date":"2013-09-09T11:24:00.000Z","updated":"2017-04-09T04:10:51.750Z","comments":true,"path":"2013/09/09/bling-ring/","link":"","permalink":"http://sarojaba.github.io/2013/09/09/bling-ring/","excerpt":"","text":"고등학생들이 유명 연예인들의 집을 털다가 잡힌다는 내용의 영화이다. 실화를 바탕으로 제작되었고, 허영심에 사로잡혀 범죄라고 인식하지 못하는 성숙하지 못한 10대들의 모습을 잘 보여준다. 긴장감을 불러 일으키는 요소는 전혀 없고, 그냥 아무 생각없이 끝까지 보았다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Bling Ring","slug":"Bling-Ring","permalink":"http://sarojaba.github.io/tags/Bling-Ring/"}]},{"title":"now-you-see-me","slug":"now-you-see-me","date":"2013-08-25T10:40:00.000Z","updated":"2017-04-09T04:11:05.698Z","comments":true,"path":"2013/08/25/now-you-see-me/","link":"","permalink":"http://sarojaba.github.io/2013/08/25/now-you-see-me/","excerpt":"","text":"길거리 마술사 4명이 한 팀이 되어 은행을 턴다는 내용이다. 마술을 취미로 했던 나에게는 더욱 뜻있는 영화이다. 감독이 마술사들에게 조언을 많이 구한 듯 보인다. 특히 마술이란 무엇인가에 대한 고찰을 엿볼 수 있었다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Magic","slug":"Magic","permalink":"http://sarojaba.github.io/tags/Magic/"},{"name":"Now You See Me","slug":"Now-You-See-Me","permalink":"http://sarojaba.github.io/tags/Now-You-See-Me/"}]},{"title":"fish-monger","slug":"fish-monger","date":"2013-08-17T16:57:00.000Z","updated":"2017-04-09T04:11:35.537Z","comments":true,"path":"2013/08/18/fish-monger/","link":"","permalink":"http://sarojaba.github.io/2013/08/18/fish-monger/","excerpt":"","text":"옛날에 팀원들과 만들었던 피씨몽거라는 앱에서 물고기가 헤엄치는 애니메이션만 Processing으로 포팅해봤다. Fish fish; void setup() { size(480, 270); frameRate(8); fish = new Fish(); } void draw() { background(#000055); if(!fish.isLoaded()) { return; } fish.update(); fish.draw(); } class Fish { int frame; PImage[] images = new PImage[16]; PVector position; PVector velocity; PVector acceleration; Fish() { frame = 0; position = new PVector(width / 2, height / 2); velocity = new PVector(0, 0); acceleration = new PVector(0, 0); for (int i = 0; i < images.length; i++) { String url = \"https://dl.dropboxusercontent.com/u/78244035/web/processing/img/\"; images[i] = requestImage(url + \"fish_\" + (i + 1) + \".png\"); } } void update() { acceleration.set(random(-2, 2), random(-1, 1)); velocity.add(acceleration); velocity.limit(5); position.add(velocity); position.x = max(position.x, images[0].width / 2); position.x = min(position.x, width - images[0].width / 2); position.y = max(position.y, images[0].height / 2); position.y = min(position.y, height - images[0].height / 2); } void draw() { frame %= images.length; translate(position.x, position.y); if (velocity.x > 0) { scale(-1, 1); //translate(width, 0); } imageMode(CENTER); image(images[frame], 0, 0); frame++; } boolean isLoaded() { for (int i = 0; i < images.length; i++) { if (images[i].width","categories":[],"tags":[{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"Fish Monger","slug":"Fish-Monger","permalink":"http://sarojaba.github.io/tags/Fish-Monger/"}]},{"title":"바람과-함께-사라지다","slug":"바람과-함께-사라지다","date":"2013-08-17T05:05:00.000Z","updated":"2017-04-09T04:11:55.160Z","comments":true,"path":"2013/08/17/바람과-함께-사라지다/","link":"","permalink":"http://sarojaba.github.io/2013/08/17/바람과-함께-사라지다/","excerpt":"","text":"억울한 누명을 쓴 주인공들이 조선시대 서빙고의 얼음을 훔치고 탐관오리를 처벌한다는 내용. 차태현, 오지호 주연의 코메디 가족영화이다. 전체적으로 재밌었고, 개인적으론 배우 민효린보단 이채영이 더 이쁜듯.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"바람과 함께 사라지다","slug":"바람과-함께-사라지다","permalink":"http://sarojaba.github.io/tags/바람과-함께-사라지다/"}]},{"title":"the-fantastic-four","slug":"the-fantastic-four","date":"2013-08-15T02:39:00.000Z","updated":"2017-04-09T04:12:40.455Z","comments":true,"path":"2013/08/15/the-fantastic-four/","link":"","permalink":"http://sarojaba.github.io/2013/08/15/the-fantastic-four/","excerpt":"","text":"우주선에서 태양광선에 쏘여 특수한 능력을 가지게 되어 영웅이 되는 4명의 이야기를 그리고 있다. 마블의 만화를 원작으로한 히어로물이라 유치하지만 재미있다. 제시카 알바는 언제봐도 섹시하다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"The Fantastic Four","slug":"The-Fantastic-Four","permalink":"http://sarojaba.github.io/tags/The-Fantastic-Four/"}]},{"title":"man-of-steel","slug":"man-of-steel","date":"2013-08-05T16:21:00.000Z","updated":"2017-04-09T04:13:02.586Z","comments":true,"path":"2013/08/06/man-of-steel/","link":"","permalink":"http://sarojaba.github.io/2013/08/06/man-of-steel/","excerpt":"","text":"슈퍼맨의 탄생을 그린 영화이다. 요즘 히어로물에 흥미가 가는 편이다. 속편도 얼른 나왔으면 좋겠다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Man of Steel","slug":"Man-of-Steel","permalink":"http://sarojaba.github.io/tags/Man-of-Steel/"}]},{"title":"남자사용설명서","slug":"남자사용설명서","date":"2013-08-05T01:20:00.000Z","updated":"2017-04-09T04:13:18.002Z","comments":true,"path":"2013/08/05/남자사용설명서/","link":"","permalink":"http://sarojaba.github.io/2013/08/05/남자사용설명서/","excerpt":"","text":"연예초보인 감독 지망생이 남자사용설명서를 보게되면서 스타와 연애하게되는 이야기이다. 로맨틱 코메디는 뭘 봐도 재밌다. 특히 배우 오정세의 코믹 연기가 너무 재미있다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"남자사용설명서","slug":"남자사용설명서","permalink":"http://sarojaba.github.io/tags/남자사용설명서/"}]},{"title":"sum-of-the-angles-of-a-triangle","slug":"sum-of-the-angles-of-a-triangle","date":"2013-08-04T17:27:00.000Z","updated":"2017-04-09T04:13:32.362Z","comments":true,"path":"2013/08/05/sum-of-the-angles-of-a-triangle/","link":"","permalink":"http://sarojaba.github.io/2013/08/05/sum-of-the-angles-of-a-triangle/","excerpt":"","text":"Triangle t; void setup() { size(480, 270); t = new Triangle(200, 30, 300, 200, 40, 200); } void draw() { background(255); t.draw(); int sum = 0; String s = \"\"; for (int i = 0; i < t.nodes.length; i++) { Node n = t.nodes[i]; int a = int(round(degrees(n.getAngle()))); sum += a; s += a + \"+\"; } s.substring(s.length() - 1); s += \"=\" + sum; fill(0); textAlign(RIGHT, TOP); text(s, width - 10, 10); } void mouseDragged() { t.mouseDragged(); } class Triangle { Node[] nodes; boolean editable; // show handle; boolean angle; // show angle; Triangle(float x1, float y1, float x2, float y2, float x3, float y3) { this(new PVector(x1, y1), new PVector(x2, y2), new PVector(x3, y3)); } Triangle(PVector p1, PVector p2, PVector p3) { nodes = new Node[3]; Node v1 = new Node(p1); Node v2 = new Node(p2); Node v3 = new Node(p3); v1.pre = v3; v1.next = v2; v2.pre = v1; v2.next = v3; v3.pre = v2; v3.next = v1; nodes[0] = v1; nodes[1] = v2; nodes[2] = v3; editable = true; angle = true; } void draw() { // draw shape pushStyle(); fill(255); beginShape(); for (int i = 0; i < nodes.length; i++) { Node n = nodes[i]; vertex(n.pos.x, n.pos.y); } endShape(CLOSE); popStyle(); // draw handle pushStyle(); if (editable) { noStroke(); fill(color(128, 128, 128, 63)); for (int i = 0; i < nodes.length; i++) { Node n = nodes[i]; ellipse(n.pos.x, n.pos.y, 20, 20); } } popStyle(); if (angle) { pushStyle(); colorMode(HSB); int h = 0; // angle arc for (int i = 0; i < nodes.length; i++) { Node n = nodes[i]; PVector v = PVector.sub(n.pre.pos, n.pos); PVector w = PVector.sub(n.next.pos, n.pos); float vh = heading(v); float wh = heading(w); // map heading to radians if (vh < 0) { vh += PI * 2; } if (wh < 0) { wh += PI * 2; } // determine face(clockwise) PVector c = v.cross(w); boolean face = c.z < 0; float a = face ? vh : wh; float b = face ? wh : vh; fill(color(h, 255, 255, 127)); h += 85; if (a > b) { arc(n.pos.x, n.pos.y, 40, 40, b, a); } else { arc(n.pos.x, n.pos.y, 40, 40, b, 2 * PI); arc(n.pos.x, n.pos.y, 40, 40, 0, a); } } popStyle(); // angle value pushStyle(); for (int i = 0; i < nodes.length; i++) { Node n = nodes[i]; PVector v = PVector.sub(n.pre.pos, n.pos); PVector w = PVector.sub(n.next.pos, n.pos); PVector z = PVector.add(v, w); z.limit(30); z.add(n.pos); fill(0); textAlign(CENTER, CENTER); text(int(round(degrees(n.getAngle()))), z.x, z.y); } popStyle(); } } void mouseDragged() { if (editable) { for (int i = 0; i < nodes.length; i++) { Node n = nodes[i]; Circle c = new Circle(n.pos.x, n.pos.y, 30); if (c.isInner(mouseX, mouseY)) { n.pos.x = mouseX; n.pos.y = mouseY; return; } } } } // function to accomplish PVector.heading() [not avaiable in Processing.js] float heading(PVector vector) { return atan2(vector.y, vector.x); } } class Node { PVector pos; // position Node pre; Node next; Node(PVector p) { pos = p; } float getAngle() { PVector v = PVector.sub(pre.pos, pos); PVector w = PVector.sub(next.pos, pos); return PVector.angleBetween(v, w); } } class Circle { // the point equidistant from the points on the circle. PVector centre; // a line segment joining the centre of the circle to any point on the circle itself; or the length of such a segment, which is half a diameter. float radius; Circle(PVector c, float r) { centre = c; radius = r; } Circle(float x, float y, float r) { this(new PVector(x, y), r); } float diameter() { return 2 * radius; } float circumference() { // 2 * PI * radius return PI * diameter(); } // area enclosed float area() { return PI * sq(radius); } // t: theta radian PVector cartesian(float t) { float x = centre.x + radius * cos(t); float y = centre.y + radius * sin(t); return new PVector(x, y); } float polar(PVector p) { return atan(p.y - centre.y / p.x - centre.x); } PVector[] tangentLine(PVector p) { PVector[] lines = new PVector[2]; PVector v = PVector.sub(centre, p); float m = v.mag(); float t = asin(radius / m); float m2 = cos(t) * m; PVector v2 = v.get(); v2.rotate(t); v2.setMag(m2); lines[0] = PVector.add(v2, p); v2 = v.get(); v2.rotate(-t); v2.setMag(m2); lines[1] = PVector.add(v2, p); return lines; } boolean isInner(float x, float y) { PVector p = new PVector(x, y); return PVector.dist(centre, p) < radius; } void draw() { ellipse(centre.x, centre.y, radius * 2, radius * 2); } }","categories":[],"tags":[{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"Triangle","slug":"Triangle","permalink":"http://sarojaba.github.io/tags/Triangle/"},{"name":"Math","slug":"Math","permalink":"http://sarojaba.github.io/tags/Math/"}]},{"title":"the-host","slug":"the-host","date":"2013-07-31T13:53:00.000Z","updated":"2017-04-09T04:15:42.119Z","comments":true,"path":"2013/07/31/the-host/","link":"","permalink":"http://sarojaba.github.io/2013/07/31/the-host/","excerpt":"","text":"인간의 몸에 기생하는 외계 생명체가 인간의 편이 되어가는 과정을 그린 영화이다. SF 장르지만 신기한 장면은 그리 많이 나오지 않는다. 신기하게도 영화에 딱 한 명(?) 빼고 나머지는 다 착하다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"The Host","slug":"The-Host","permalink":"http://sarojaba.github.io/tags/The-Host/"}]},{"title":"더-웹툰-예고살인","slug":"더-웹툰-예고살인","date":"2013-07-30T13:30:00.000Z","updated":"2017-04-09T04:16:35.510Z","comments":true,"path":"2013/07/30/더-웹툰-예고살인/","link":"","permalink":"http://sarojaba.github.io/2013/07/30/더-웹툰-예고살인/","excerpt":"","text":"유명 만화작가가 그리는대로 살인이 일어나는 이유는? 공포스러움보다 스릴러에 가까운 느낌? 다음이 지원을 많이 해준 듯?","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"더 웹툰","slug":"더-웹툰","permalink":"http://sarojaba.github.io/tags/더-웹툰/"}]},{"title":"bubble-pop","slug":"bubble-pop","date":"2013-07-28T15:15:00.000Z","updated":"2017-04-09T04:16:47.489Z","comments":true,"path":"2013/07/29/bubble-pop/","link":"","permalink":"http://sarojaba.github.io/2013/07/29/bubble-pop/","excerpt":"","text":"비누방울이 터지는 것을 표현해 보았습니다. int min; int max; void setup() { size(320, 180); frameRate(8); min = 0; max = 100; } void draw() { // clear slowly noStroke(); colorMode(RGB); fill(color(255, 255, 255, 127)); rect(0, 0, width, height); // draw circle colorMode(HSB); fill(random(255), 255, 255); float diam = random(min, max); ellipse(random(width), random(height), diam, diam); } void setRange(int[] range) { min = range[0]; max = range[1]; } int min; int max; void setup() { size(320, 180); frameRate(8); min = 0; max = 100; } void draw() { // clear slowly noStroke(); colorMode(RGB); fill(color(255, 255, 255, 127)); rect(0, 0, width, height); // draw circle colorMode(HSB); fill(random(255), 255, 255); float diam = random(min, max); ellipse(random(width), random(height), diam, diam); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"Bubble Pop","slug":"Bubble-Pop","permalink":"http://sarojaba.github.io/tags/Bubble-Pop/"}]},{"title":"analog-clock","slug":"analog-clock","date":"2013-07-27T15:23:00.000Z","updated":"2017-04-09T04:16:59.449Z","comments":true,"path":"2013/07/28/analog-clock/","link":"","permalink":"http://sarojaba.github.io/2013/07/28/analog-clock/","excerpt":"","text":"아날로그 시계를 만들어보았다. 흘러가는 세월아&hellip; int s; // size float r; void setup() { s = 300; r = s / 2; size(s, s); smooth(); frameRate(15); } void draw() { strokeWeight(1.5); // translate to center translate(s / 2, s / 2); rotate(radians(270)); // draw circle stroke(#000000); fill(#FFFFFF); ellipse(0, 0, s, s); // draw hour numbers float u = radians(360 / 12); for(int h = 0; h < 12; h++) { pushMatrix(); float x = (r * 0.9) * cos(h * u); float y = (r * 0.9) * sin(h * u); translate(x, y); rotate(radians(90)); fill(#000000); textAlign(CENTER, CENTER); text(h, 0, 0); popMatrix(); } // second needle float ts = radians(second() * (360 / 60)); stroke(#FF0000); line(0, 0, (r * 0.9) * cos(ts), (r * 0.9) * sin(ts)); // minute needle float tm = radians(minute() * (360 / 60)); stroke(#00FF00); line(0, 0, (r * 0.8) * cos(tm), (r * 0.8) * sin(tm)); // hour needle float th = radians(hour() * (360 / 12)); stroke(#0000FF); line(0, 0, (r * 0.7) * cos(th), (r * 0.7) * sin(th)); } int s; // size float r; void setup() { s = 300; r = s / 2; size(s, s); smooth(); frameRate(15); } void draw() { strokeWeight(1.5); // translate to center translate(s / 2, s / 2); rotate(radians(270)); // draw circle stroke(#000000); fill(#FFFFFF); ellipse(0, 0, s, s); // draw hour numbers float u = radians(360 / 12); for(int h = 0; h &lt; 12; h++) { pushMatrix(); float x = (r * 0.9) * cos(h * u); float y = (r * 0.9) * sin(h * u); translate(x, y); rotate(radians(90)); fill(#000000); textAlign(CENTER, CENTER); text(h, 0, 0); popMatrix(); } // second needle float ts = radians(second() * (360 / 60)); stroke(#FF0000); line(0, 0, (r * 0.9) * cos(ts), (r * 0.9) * sin(ts)); // minute needle float tm = radians(minute() * (360 / 60)); stroke(#00FF00); line(0, 0, (r * 0.8) * cos(tm), (r * 0.8) * sin(tm)); // hour needle float th = radians(hour() * (360 / 12)); stroke(#0000FF); line(0, 0, (r * 0.7) * cos(th), (r * 0.7) * sin(th)); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"Analog Clock","slug":"Analog-Clock","permalink":"http://sarojaba.github.io/tags/Analog-Clock/"}]},{"title":"untitled-1","slug":"untitled-1","date":"2013-07-25T16:05:00.000Z","updated":"2017-04-09T04:17:14.145Z","comments":true,"path":"2013/07/26/untitled-1/","link":"","permalink":"http://sarojaba.github.io/2013/07/26/untitled-1/","excerpt":"","text":"int s; // size int u; // unit PVector p; // line position PVector d; // direction void setup() { s = 300; u = 2; p = new PVector(0, 0); d = new PVector(u, 0); // left to right size(s, s); background(#FFFFFF); colorMode(HSB, s / u); } void draw() { // direction if(p.x > s) { p.x = s; d.x = 0; d.y = u; } else if(p.y > s) { p.y = s; d.x = -u; d.y = 0; } else if(p.x < 0) { p.x = 0; d.x = 0; d.y = -u; } else if(p.y < 0) { p.y = 0; d.x = u; d.y = 0; } // draw stroke(frameCount % (s / u), 127, 127); line(p.x, p.y, s - p.y, p.x); // update p.add(d); } int s; // size int u; // unit PVector p; // line position PVector d; // direction void setup() { s = 300; u = 2; p = new PVector(0, 0); d = new PVector(u, 0); // left to right size(s, s); background(#FFFFFF); colorMode(HSB, s / u); } void draw() { // direction if (p.x &gt; s) { p.x = s; d.x = 0; d.y = u; } else if (p.y &gt; s) { p.y = s; d.x = -u; d.y = 0; } else if (p.x &lt; 0) { p.x = 0; d.x = 0; d.y = -u; } else if (p.y &lt; 0) { p.y = 0; d.x = u; d.y = 0; } // draw stroke(frameCount % (s / u), 127, 127); line(p.x, p.y, s - p.y, p.x); // update p.add(d); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"}]},{"title":"oblivion","slug":"oblivion","date":"2013-07-24T16:13:00.000Z","updated":"2017-04-09T04:17:30.497Z","comments":true,"path":"2013/07/25/oblivion/","link":"","permalink":"http://sarojaba.github.io/2013/07/25/oblivion/","excerpt":"","text":"드론을 수리하는 잭이 기억을 찾아가며 진짜 적을 물리치는 이야기이다. 컴퓨터가 우주에서 지시하는 것과 톰 그루즈가 타고 다니는 비행선이 독특했다. SF 장르를 좋아하기 때문에 재미있게 보았다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Oblivion","slug":"Oblivion","permalink":"http://sarojaba.github.io/tags/Oblivion/"}]},{"title":"breakout","slug":"breakout","date":"2013-07-21T11:45:00.000Z","updated":"2017-04-09T04:17:44.704Z","comments":true,"path":"2013/07/21/breakout/","link":"","permalink":"http://sarojaba.github.io/2013/07/21/breakout/","excerpt":"","text":"프로세싱으로 만들어보았다. 교육용 샘플 정도로만 만들었기 때문에 더 이상 버전업은 하지 않을듯&hellip; &lsquo;R&rsquo; 키를 누르면 재시작한다. PVector pos; PVector delta; int paddle; int nrows; int ncols; float bwidth; float bheight; boolean[][] bricks; void setup() { size(320, 240); smooth(); colorMode(HSB); pos = new PVector(width / 2, height / 2); delta = new PVector(-2, -2); paddle = 20; nrows = 5; ncols = 5; bwidth = width / ncols; bheight = 15; bricks = new boolean[nrows][ncols]; reset(); } void draw() { // clear background(#FFFFFF); // hit wall ? if (pos.x < 0 || pos.x > width) { delta.x = -delta.x; } if (pos.y < 0) { delta.y = -delta.y; } // hit paddle ? if (pos.y > height) { if (pos.x > mouseX - paddle && pos.x < mouseX + paddle) { delta.y = -delta.y; } } // hit brick ? for (int r = 0; r < nrows; r++) { for (int c = 0; c < ncols; c++) { if (bricks[r][c]) { if (pos.x > bwidth * c && pos.x < bwidth * (c + 1) && pos.y > bheight * r && pos.y < bheight * (r + 1)) { // remove brick bricks[r][c] = false; // bound ball delta.y = -delta.y; } } } } // draw paddle stroke(#000000); strokeWeight(10); line(mouseX - paddle, height, mouseX + paddle, height); // draw ball noStroke(); fill(#000000); ellipse(pos.x, pos.y, 20, 20); // draw bricks stroke(#FFFFFF); strokeWeight(1); for (int r = 0; r < nrows; r++) { fill(color(255.0 / nrows * r, 255, 255)); for (int c = 0; c < ncols; c++) { if (bricks[r][c]) { rect(bwidth * c, bheight * r, bwidth, bheight); } } } // move pos.x += delta.x; pos.y += delta.y; } void keyPressed() { if(key == 'r' || key == 'R') { reset(); } } void reset() { // pos pos.x = width / 2; pos.y = height / 2; // delta delta.x = -2; delta.y = -2; // brick for (int r = 0; r < nrows; r++) { for (int c = 0; c < ncols; c++) { bricks[r][c] = true; } } } PVector pos; PVector delta; int paddle; int nrows; int ncols; float bwidth; float bheight; boolean[][] bricks; void setup() { size(320, 240); smooth(); colorMode(HSB); pos = new PVector(width / 2, height / 2); delta = new PVector(-2, -2); paddle = 20; nrows = 5; ncols = 5; bwidth = width / ncols; bheight = 15; bricks = new boolean[nrows][ncols]; reset(); } void draw() { // clear background(#FFFFFF); // hit wall ? if (pos.x &lt; 0 || pos.x &gt; width) { delta.x = -delta.x; } if (pos.y &lt; 0) { delta.y = -delta.y; } // hit paddle ? if (pos.y &gt; height) { if (pos.x &gt; mouseX - paddle &amp;&amp; pos.x &lt; mouseX + paddle) { delta.y = -delta.y; } } // hit brick ? for (int r = 0; r &lt; nrows; r++) { for (int c = 0; c &lt; ncols; c++) { if (bricks[r][c]) { if (pos.x &gt; bwidth * c &amp;&amp; pos.x &lt; bwidth * (c + 1) &amp;&amp; pos.y &gt; bheight * r &amp;&amp; pos.y &lt; bheight * (r + 1)) { // remove brick bricks[r][c] = false; // bound ball delta.y = -delta.y; } } } } // draw paddle stroke(#000000); strokeWeight(10); line(mouseX - paddle, height, mouseX + paddle, height); // draw ball noStroke(); fill(#000000); ellipse(pos.x, pos.y, 20, 20); // draw bricks stroke(#FFFFFF); strokeWeight(1); for (int r = 0; r &lt; nrows; r++) { fill(color(255.0 / nrows * r, 255, 255)); for (int c = 0; c &lt; ncols; c++) { if (bricks[r][c]) { rect(bwidth * c, bheight * r, bwidth, bheight); } } } // move pos.x += delta.x; pos.y += delta.y; } void keyPressed() { if(key == &apos;r&apos; || key == &apos;R&apos;) { reset(); } } void reset() { // pos pos.x = width / 2; pos.y = height / 2; // delta delta.x = -2; delta.y = -2; // brick for (int r = 0; r &lt; nrows; r++) { for (int c = 0; c &lt; ncols; c++) { bricks[r][c] = true; } } }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"Breakout","slug":"Breakout","permalink":"http://sarojaba.github.io/tags/Breakout/"},{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"}]},{"title":"tumblr에-processing-포스팅-하기","slug":"tumblr에-processing-포스팅-하기","date":"2013-07-20T13:52:00.000Z","updated":"2017-04-09T04:18:00.324Z","comments":true,"path":"2013/07/20/tumblr에-processing-포스팅-하기/","link":"","permalink":"http://sarojaba.github.io/2013/07/20/tumblr에-processing-포스팅-하기/","excerpt":"","text":"저는 텀블러(Tumblr)라고 하는 블로깅 서비스를 사용하고 있는데요. 오늘은 텀블러에 프로세싱(Processing)을 포스팅하는 방법에 대해 알아보도록 하겠습니다. 방법은 무척 쉽습니다. 텀블러의 포스팅 종류를 Text로 선택하고 아래 소스코드 안에 프로세싱 코드를 포함하여 입력하시면 됩니다. &lt;script src=&quot;https://github.com/downloads/processing-js/processing-js/processing-1.4.1.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/processing&quot; data-processing-target=&quot;processing-canvas-hello&quot;&gt; void setup() { size(320, 340); } void draw() { ellipse(width / 2, height / 2, 50, 50); } &lt;/script&gt; &lt;canvas id=&quot;processing-canvas-hello&quot;&gt; &lt;/canvas&gt; 다음의 두 가지 항목만 유의하시기 바랍니다. script 태그의 data-processing-target 속성값과 canvas 태그의 id 속성값은 임의로 주어도 되지만 둘은 항상 같아야 합니다. ex) &ldquo;processing-canvas-hello&rdquo; 각 게시물마다 위의 속성값들이 달라야 합니다. 왜냐하면 여러 게시물에 하나의 페이지에 표시될 경우 캔버스의 ID가 겹치므로 제대로 표시되지 않을 수 있습니다. 이제 프로세싱 공부도 열심히 하고, 블로그에 자랑도 해보아요~ ㅎㅎ","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"}]},{"title":"태극-마크","slug":"태극-마크","date":"2013-07-20T05:32:00.000Z","updated":"2017-04-09T04:18:24.268Z","comments":true,"path":"2013/07/20/태극-마크/","link":"","permalink":"http://sarojaba.github.io/2013/07/20/태극-마크/","excerpt":"","text":"프로세싱으로 태극 마크를 그려봤습니다. 애국심이 생겨나네요. void setup() { int unit = 150; // 3:2 size(unit * 3, unit * 2); noLoop(); smooth(); } void draw() { noStroke(); // white background(255); // center translate(width / 2, height / 2); float t = atan2(height, width); rotate(t); scale(0.5); // north fill(255, 0, 0); arc(0, 0, height, height, PI, PI * 2); // south fill(0, 0, 255); arc(0, 0, height, height, 0, PI); scale(0.5); pushMatrix(); translate(-height / 2, 0); fill(255, 0, 0); ellipse(0, 0, height, height); popMatrix(); pushMatrix(); translate(height / 2, 0); fill(0, 0, 255); ellipse(0, 0, height, height); popMatrix(); } void setup() { int unit = 150; // 3:2 size(unit * 3, unit * 2); noLoop(); smooth(); } void draw() { noStroke(); // white background(255); // center translate(width / 2, height / 2); float t = atan2(height, width); rotate(t); scale(0.5); // north fill(255, 0, 0); arc(0, 0, height, height, PI, PI * 2); // south fill(0, 0, 255); arc(0, 0, height, height, 0, PI); scale(0.5); pushMatrix(); translate(-height / 2, 0); fill(255, 0, 0); ellipse(0, 0, height, height); popMatrix(); pushMatrix(); translate(height / 2, 0); fill(0, 0, 255); ellipse(0, 0, height, height); popMatrix(); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"}]},{"title":"notting-hill","slug":"notting-hill","date":"2013-07-11T16:23:00.000Z","updated":"2017-04-09T04:19:04.975Z","comments":true,"path":"2013/07/12/notting-hill/","link":"","permalink":"http://sarojaba.github.io/2013/07/12/notting-hill/","excerpt":"","text":"영화 홍보를 위해 영국에 방문한 여배우가 평범한 남자를 만나면서 서로 사랑에 빠지는 이야기이다. 남자가 휴 그랜트처럼 멋있어야 여자가 적극적이 된다는 교훈을 남겨준다. 영화 OST인 She 라는 곡이 이 영화의 엔딩을 멋지게 장식해준다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Notting Hill","slug":"Notting-Hill","permalink":"http://sarojaba.github.io/tags/Notting-Hill/"},{"name":"Hugh Grant","slug":"Hugh-Grant","permalink":"http://sarojaba.github.io/tags/Hugh-Grant/"},{"name":"Julia Roberts","slug":"Julia-Roberts","permalink":"http://sarojaba.github.io/tags/Julia-Roberts/"}]},{"title":"미인도","slug":"미인도","date":"2013-06-24T13:05:00.000Z","updated":"2017-04-09T04:19:17.811Z","comments":true,"path":"2013/06/24/미인도/","link":"","permalink":"http://sarojaba.github.io/2013/06/24/미인도/","excerpt":"","text":"조선시대 화원을 배경으로 신윤복의 이루어지지 못한 사랑을 소재로 한 영화이다. 김흥도와 신윤복이라는 역사속 인물을 살아있는 캐릭터로 표현하였다. 개인적인 생각으로는 여배우 김규리의 노출 연기가 너무 많이 나왔다. 작품에서 꼭 필요했는지&hellip; 관객을 위해서 였는지&hellip;","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"미인도","slug":"미인도","permalink":"http://sarojaba.github.io/tags/미인도/"}]},{"title":"copying-arrays-in-java-6-2","slug":"copying-arrays-in-java-6-2","date":"2013-06-23T06:25:00.000Z","updated":"2017-04-09T04:19:30.255Z","comments":true,"path":"2013/06/23/copying-arrays-in-java-6-2/","link":"","permalink":"http://sarojaba.github.io/2013/06/23/copying-arrays-in-java-6-2/","excerpt":"","text":"자바 6에서는 더 이상 이런 역할의 유틸리티 메소드가 필요가 없다. 썬은 배열의 복사를 위한 직접 지원을 소개한다. 썬은 새로운 Arrays 클래스의 오버로드된 메소드인 copyOf 를 정의한다. targetArray = Arrays.copyOf(sourceArray, length); `&lt;/pre&gt; 여기서는 copyOf 메소드의 행동을 시연해보기 위해 JUnit test를 몇 개 사용하였다. 여기에 기본 기능을 보여주는 첫번째 테스트가 있다. &lt;pre&gt;`@Test public void genericArrayCopyOf() { Number[] source = { new Double(5.0), new Double(10.0) }; Number[] target = Arrays.copyOf(source, source.length); assertEquals(source, target); } `&lt;/pre&gt; JUnit 4의 새로운 특징중의 하나는 assertEquals를 사용한 두개의 배열의 비교 능력이다. 그 작업을 할 때, JUnit는 첫째로 각 배열의 크기를 비교한다. 만약 두 배열이 같다면 JUnit은 equals을 사용하여 각각의 요소들을 비교한다. 두 배열이 다르면, JUnit은 failure 메시지를 나타내어 부등호 값을 보여준다. 자바는 두개의 다른 변수로 기본형 타입을 지원을 위해 copyOf 를 오버로드한다. 또 다른 테스트는 원본의 범위를 지원할 수 있는 방법을 보여준다. &lt;pre&gt;`@Test public void copyOfWithRange() { String[] source = { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; }; String[] target = Arrays.copyOfRange(source, 2, 4); assertEquals(new String[] { &quot;2&quot;, &quot;3&quot; }, target); } @Test public void primitives() { int[] source = { 0, 1, 2, 3, 4 }; int[] target = Arrays.copyOfRange(source, 4, 5); assertEqualsPrim(new int[] { 4 }, target); } `&lt;/pre&gt; JUnit 4는 기본형 타입을 가지고 있는 두 배열을 비교할 수 없기에 assertEqualsPrim 메소드를 작성했다. It contains only a version that compares two Object arrays. assertEquals 를 이용해 두 기본형 타입의 배열을 비교하는 것은 자바가 메모리 비교를 하는 것을 의미한다. 별거 아니게, assertEqualsPrim 를 작성하는 것은 아주 쉽다. &lt;pre&gt;`static void assertEqualsPrim(int[] expected, int[] actual) { if (expected.length != actual.length) fail(String.format(&quot;expected length = %s, actual length = %s&quot;, expected.length, actual.length)); for (int i = 0; i &lt; expected.length; i++) { if (expected[i] != actual[i]) fail(String.format( &quot;mismatch at index %d: expected [%s] but was [%s]&quot;, i, expected[i], actual[i])); } } `&lt;/pre&gt; What if I want the new array to be of a new, subclass type? The following test fails: &lt;pre&gt;`@Test public void genericArrayCopyOfWithNewType() { Number[] source = { new Double(5.0), new Double(10.0) }; Double[] target = (Double[])Arrays.copyOf(source, source.length); assertEquals(source, target); // fail! } `&lt;/pre&gt; But Java 6 allows me to declare a new type for the target array on a copy: &lt;pre&gt;`@Test public void genericArrayCopyOfWithNewType() { Number[] source = { new Double(5.0), new Double(10.0) }; Double[] target = Arrays.copyOf(source, source.length, Double[].class); assertEquals(source, target); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Array","slug":"Array","permalink":"http://sarojaba.github.io/tags/Array/"}]},{"title":"moon-night","slug":"moon-night","date":"2013-06-20T13:50:00.000Z","updated":"2017-04-09T04:19:45.963Z","comments":true,"path":"2013/06/20/moon-night/","link":"","permalink":"http://sarojaba.github.io/2013/06/20/moon-night/","excerpt":"","text":"OpenGL 레포트였던 밤하늘에 떠있는 달과 별을 그려보았다. 별의 좌표는 랜덤으로 주어지고, 달은 원의 좌표를 계산하여 그렸다. 지형은 일직선을 재귀적으로 쪼개서 각도를 변경하여 그렸다. void setup(){ size(300, 240, P2D); background(0); noLoop(); noStroke(); } void draw(){ drawSky(); drawStars(50); drawEclipse(); drawMountain(height / 1.5); } void drawSky(){ // gradient color night = color(0, 0, 125); color glow = color(255, 102, 0); for(int i = 0; i < height; i++){ float rate = map(i, 0, height, 0, 1); color c = lerpColor(night, glow, rate); stroke(c); line(0, i, width, i); } } void drawStars(int num){ stroke(255); for(int i = 0; i < num; i++){ int x = random(width); int y = random(height / 2); point(x, y); } } void drawEclipse(){ noStroke(); color yellow = color(255, 255, 0); fill(yellow); int cx = width / 2; int cy = width / 4; int r = 30; beginShape(); for(int i = -45; i < 135; i++){ int x = cx + r * cos(radians(i)); int y = cy + r * sin(radians(i)); vertex(x, y); } for(int i = 135; i > -45; i--){ int x = cx - 10 + r * cos(radians(i)); int y = cy - 10 + r * sin(radians(i)); vertex(x, y); } endShape(CLOSE); } void drawMountain(int tall){ beginShape(); vertex(0, height); vertex(0, tall); breakLine(0, tall, width, tall); vertex(width, tall); vertex(width, height); endShape(CLOSE); } void breakLine(int x0, int y0, int x1, int y1){ float dist = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2)); if(dist < 30){ return; } // mid point int cx = x0 + (x1 - x0) / 2; int cy = y0 + (y1 - y0) / 2; int x2 = cx + (dist / 8) * cos(QUARTER_PI * random(8)); int y2 = cy + (dist / 8) * sin(QUARTER_PI * random(8)); breakLine(x0, y0, x2, y2); vertex(x2, y2); breakLine(x2, y2, x1, y1); } void setup(){ size(300, 240, P2D); background(0); noLoop(); noStroke(); } void draw(){ drawSky(); drawStars(50); drawEclipse(); drawMountain(height / 1.5); } void drawSky(){ // gradient color night = color(0, 0, 125); color glow = color(255, 102, 0); for(int i = 0; i &lt; height; i++){ float rate = map(i, 0, height, 0, 1); color c = lerpColor(night, glow, rate); stroke(c); line(0, i, width, i); } } void drawStars(int num){ stroke(255); for(int i = 0; i &lt; num; i++){ int x = random(width); int y = random(height / 2); point(x, y); } } void drawEclipse(){ noStroke(); color yellow = color(255, 255, 0); fill(yellow); int cx = width / 2; int cy = width / 4; int r = 30; beginShape(); for(int i = -45; i &lt; 135; i++){ int x = cx + r * cos(radians(i)); int y = cy + r * sin(radians(i)); vertex(x, y); } for(int i = 135; i &gt; -45; i--){ int x = cx - 10 + r * cos(radians(i)); int y = cy - 10 + r * sin(radians(i)); vertex(x, y); } endShape(CLOSE); } void drawMountain(int tall){ beginShape(); vertex(0, height); vertex(0, tall); breakLine(0, tall, width, tall); vertex(width, tall); vertex(width, height); endShape(CLOSE); } void breakLine(int x0, int y0, int x1, int y1){ float dist = sqrt(pow(x1 - x0, 2) + pow(y1 - y0, 2)); if(dist &lt; 30){ return; } // mid point int cx = x0 + (x1 - x0) / 2; int cy = y0 + (y1 - y0) / 2; int x2 = cx + (dist / 8) * cos(QUARTER_PI * random(8)); int y2 = cy + (dist / 8) * sin(QUARTER_PI * random(8)); breakLine(x0, y0, x2, y2); vertex(x2, y2); breakLine(x2, y2, x1, y1); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"Moon","slug":"Moon","permalink":"http://sarojaba.github.io/tags/Moon/"}]},{"title":"copying-arrays-in-java-6-1","slug":"copying-arrays-in-java-6-1","date":"2013-06-19T15:47:00.000Z","updated":"2017-04-09T04:20:01.222Z","comments":true,"path":"2013/06/20/copying-arrays-in-java-6-1/","link":"","permalink":"http://sarojaba.github.io/2013/06/20/copying-arrays-in-java-6-1/","excerpt":"","text":"자바 언어는 몇몇 대단한 유물을 가지고 있다. 예를 들어, 스위치 구문은 아직도 스트링 오브젝트를 스위칭하는 개념을 지원하지 않는다. (그러나 switch 구문은 이넘 타입을 지원하는 것으로 업데이트 되었다.) 그 이유는 과거로 돌아가 원래 C에서 디자인된 switch 구문의 개념에서 나타난다. 이유가 무엇이든, 내가 필요로 했던 스위치문에서의 스트링 사용은 불행하게도 불가능하다는 것을 알게되었다. 한 배열에서 다른 배열로 내용을 빠르게 복사하기 위해 사용되는 System.arraycopy 메소드도 비슷한 legacy를 기초로 하고 있는 것으로 보인다. 이 메소드의 이름조차 옛 스타일의 C 함수인 memcpy 와 비슷하다. 이 같은 자바에서의 배열 복사 방법은 사람들 사이에서 선호되었고, 처음 출시 후로 전혀 변하지 않았다. arraycopy 메소드는 시스템에서 정의된 정적 메소드로서 확실히 충분하게 강력하다. 시스템 클래스는 하나의 범용의 메소드를 제공한다. System.arraycopy(sourceArray, sourceStartIndex, targetArray, targetStartIndex, length); `&lt;/pre&gt; arraycopy 메소드는 단순히 원본 배열의 요소들 전체를 대상 배열로 복사하는 것보다 많은 것을 제공한다. 게다가, arraycopy는 원본과 대상의 시작 인덱스를 허용하고, 복사할 요소들의 수를 나타내는 length 또한 허용한다. 나의 경우에 항상 쓰지는 않지만, 이런 추가적인 유연성은 널리 사용된다. 예를 들어 ArrayList 클래스는 배열 내용을 이동시킬때, 사용자가 배열의 중간에 요소를 삽입하고 싶을 때 arraycopy 를 사용한다. 대부분의 경우, 일부분이 아닌 전체 배열을 복사하고 싶음에도 불구하고, 내가 배열 형태로 요소들을 시프트 시킬 일을 자주 없었다. 내가 System.arrayCopy를 사용하는 대부분의 방식은 코드 두줄이면 된다. &lt;pre&gt;`String[] source = { &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot; }; String[] target = new String[source.length]; System.arraycopy(source, 0, target, 0, source.length); `&lt;/pre&gt; 이렇게 간단하고 자주 필요한 것에서도, 자바는 너무 많은 코드를 사용한다는 생각이 든다. 만약 이런 구성을 주어진 애플리케이션에서 여러 번 사용하게 된다면, 나는 재사용 가능한 메소드를 원할 것이다. &lt;pre&gt;`private final &lt;T&gt; T[] copy(T[] source) { T[] target = new T[source.length]; // This will not compile! System.arraycopy(source, 0, target, 0, source.length); return target; } `&lt;/pre&gt; 음… 안되네. 컴파일하면 에러메시지가 나타난다. &lt;pre&gt;`Cannot create a generic array of T `&lt;/pre&gt; 리플렉션을 이용해 이 에러의 원인을 얻을 수 있다. 이것이 copy 메소드를 만든 코드이다. &lt;pre&gt;`private final &lt;T&gt; T[] copy(T[] source) { Class type = source.getClass().getComponentType(); T[] target = (T[])Array.newInstance(type, source.length); System.arraycopy(source, 0, target, 0, source.length); return target; } `&lt;/pre&gt; 자바 컴파일러는 newInstance 를 호출함에 있어서 “Type safety: the case from Object to T[] is actually checking against the erased type Object[].” 경고를 주어 주의를 표시한다. 리플렉션을 이용한다는 것은 컴파일러가 이것이 잘못된 캐스트인지 알려주는 정보가 충분하지 않다는 것을 의미한다. 더 나은 해결책이 있다면, 단순한 라우팅과 성가신 경고를 억제하는 것을 취한다. &lt;pre&gt;`@SuppressWarnings(&quot;unchecked&quot;) private final &lt;T&gt; T[] copy(T[] source) { Class type = source.getClass().getComponentType(); T[] target = (T[])Array.newInstance(type, source.length); System.arraycopy(source, 0, target, 0, source.length); return target; } String[] source = { &quot;alpha&quot;, &quot;beta&quot;, &quot;gamma&quot; }; String[] target = copy(source); 여기서 보인 것처럼, 재빠르게 범용적인 배열 복사 유틸리티 메소드를 만들 수 있다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Copy","slug":"Copy","permalink":"http://sarojaba.github.io/tags/Copy/"}]},{"title":"혜화동","slug":"혜화동","date":"2013-06-16T15:11:00.000Z","updated":"2017-04-09T04:20:19.982Z","comments":true,"path":"2013/06/17/혜화동/","link":"","permalink":"http://sarojaba.github.io/2013/06/17/혜화동/","excerpt":"","text":"본인들의 의지와는 다르게 아이를 입양보낸 젊은 남녀가 아이를 찾아가는 과정을 그린 영화이다. 생명의 소중함과 책임에 대한 메시지를 던져주고 있다. 극중 주인공인 &lsquo;혜화&rsquo; 역할에 배우 유다인의 표정 연기가 영화의 메시지를 더욱 강하게 전달할 수 있도록 만들어주는 듯 하다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"혜화동","slug":"혜화동","permalink":"http://sarojaba.github.io/tags/혜화동/"}]},{"title":"magician-justin-willman-on-the-ellen-show","slug":"magician-justin-willman-on-the-ellen-show","date":"2013-06-16T09:56:00.000Z","updated":"2017-04-09T04:20:55.918Z","comments":true,"path":"2013/06/16/magician-justin-willman-on-the-ellen-show/","link":"","permalink":"http://sarojaba.github.io/2013/06/16/magician-justin-willman-on-the-ellen-show/","excerpt":"","text":"두 가지 마술을 보여주는데 루틴이라기 보단 그냥 하나씩 따로따로 ㅋㅋ 그래도 재미있는 마술이다 ㅎㅎ","categories":[],"tags":[{"name":"Magic","slug":"Magic","permalink":"http://sarojaba.github.io/tags/Magic/"},{"name":"Justin Willman","slug":"Justin-Willman","permalink":"http://sarojaba.github.io/tags/Justin-Willman/"},{"name":"The Ellen Show","slug":"The-Ellen-Show","permalink":"http://sarojaba.github.io/tags/The-Ellen-Show/"}]},{"title":"captain-america-the-first-avenger","slug":"captain-america-the-first-avenger","date":"2013-06-16T06:38:00.000Z","updated":"2017-04-09T04:21:46.697Z","comments":true,"path":"2013/06/16/captain-america-the-first-avenger/","link":"","permalink":"http://sarojaba.github.io/2013/06/16/captain-america-the-first-avenger/","excerpt":"","text":"캡틴 아메리카의 탄생 비화를 설명해주는 스토리이다. 어벤저스를 먼저보고 보았기에 마지막 장면에서 이제 어벤저스 팀을 모으는구나 생각되었다. 마블 코믹스의 만화에 관심이 더 생겼다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Captain America","slug":"Captain-America","permalink":"http://sarojaba.github.io/tags/Captain-America/"},{"name":"The First Avenger","slug":"The-First-Avenger","permalink":"http://sarojaba.github.io/tags/The-First-Avenger/"}]},{"title":"pknu-logo","slug":"pknu-logo","date":"2013-06-13T15:39:00.000Z","updated":"2017-04-09T04:22:01.241Z","comments":true,"path":"2013/06/14/pknu-logo/","link":"","permalink":"http://sarojaba.github.io/2013/06/14/pknu-logo/","excerpt":"","text":"컴퓨터 그래픽스 수업의 레포트로 OpenGL로 작성했었던 학교 로고를 Processing 언어로 재작성하였다. 나에게 부족한 그래픽스 및 수학을 공부할 수 있는 최적의 환경이 갖춰졌다. 단기적으로는 다른 레포트도 재작성해보고, 장기적으로는 여러 창의적인 작품을 더 만들고 싶다. color navy = color(0, 56, 118); color sky = color(0, 154, 218); color white = color(255); void setup() { size(140, 120); background(255); noStroke(); noLoop(); } void draw(){ drawLeftCresent(); drawRightCresent(); drawCenterFullMoon(); drawCenterDiamond(); } void drawLeftCresent() { // left half circle fill(navy); arc(width / 2 - 20, height / 2, 82, 82, PI * 0.5, PI * 1.5); // left half circle fill(white); arc(width / 2 - 8, height / 2, 84, 84, PI * 0.5, PI * 1.5); } void drawRightCresent() { // right half circle fill(sky); arc(width / 2 + 20, height / 2, 82, 82, PI * -0.5 , PI * 0.5); // right half circle fill(white); arc(width / 2 + 8, height / 2, 84, 84, PI * -0.5 , PI * 0.5); } void drawCenterFullMoon() { // left half circle fill(sky); arc(width / 2, height / 2, 80, 80, PI * 0.5, PI * 1.5); // right half circle fill(navy); arc(width / 2, height / 2, 80, 80, PI * -0.5 , PI * 0.5); } void drawCenterDiamond() { // north-west triangle fill(sky); triangle(width / 2, 0, width / 2, height / 2, (width / 2) - 14, height / 2); // south-east triangle fill(navy); triangle(width / 2, height, width / 2, height / 2, (width / 2) + 14, height / 2); // north-east & south-west triangle fill(white); triangle(width / 2, 0, width / 2, height / 2, (width / 2) + 14, height / 2); triangle(width / 2, height, width / 2, height / 2, (width / 2) - 14, height / 2); } color navy = color(0, 56, 118); color sky = color(0, 154, 218); color white = color(255); void setup() { size(140, 120); background(255); noStroke(); noLoop(); } void draw(){ drawLeftCresent(); drawRightCresent(); drawCenterFullMoon(); drawCenterDiamond(); } void drawLeftCresent() { // left half circle fill(navy); arc(width / 2 - 20, height / 2, 82, 82, PI * 0.5, PI * 1.5); // left half circle fill(white); arc(width / 2 - 8, height / 2, 84, 84, PI * 0.5, PI * 1.5); } void drawRightCresent() { // right half circle fill(sky); arc(width / 2 + 20, height / 2, 82, 82, PI * -0.5 , PI * 0.5); // right half circle fill(white); arc(width / 2 + 8, height / 2, 84, 84, PI * -0.5 , PI * 0.5); } void drawCenterFullMoon() { // left half circle fill(sky); arc(width / 2, height / 2, 80, 80, PI * 0.5, PI * 1.5); // right half circle fill(navy); arc(width / 2, height / 2, 80, 80, PI * -0.5 , PI * 0.5); } void drawCenterDiamond() { // north-west triangle fill(sky); triangle(width / 2, 0, width / 2, height / 2, (width / 2) - 14, height / 2); // south-east triangle fill(navy); triangle(width / 2, height, width / 2, height / 2, (width / 2) + 14, height / 2); // north-east &amp; south-west triangle fill(white); triangle(width / 2, 0, width / 2, height / 2, (width / 2) + 14, height / 2); triangle(width / 2, height, width / 2, height / 2, (width / 2) - 14, height / 2); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Processing","slug":"Processing","permalink":"http://sarojaba.github.io/tags/Processing/"},{"name":"PKNU","slug":"PKNU","permalink":"http://sarojaba.github.io/tags/PKNU/"}]},{"title":"마르코-템페스트marco-tempest-독특한-사이버-카드-마술사","slug":"마르코-템페스트marco-tempest-독특한-사이버-카드-마술사","date":"2013-06-13T15:28:00.000Z","updated":"2017-04-09T04:22:15.373Z","comments":true,"path":"2013/06/14/마르코-템페스트marco-tempest-독특한-사이버-카드-마술사/","link":"","permalink":"http://sarojaba.github.io/2013/06/14/마르코-템페스트marco-tempest-독특한-사이버-카드-마술사/","excerpt":"","text":"과학기술과 마술을 접목하는 것으로 유명한 마르코 템페스트의 TED 영상 중 하나이다. 증강현실과 스토리텔링을 카드 마술에 접목하였다. 마술에서의 새로운 분야를 개척하는 대단한 인물임에 틀림이 없다.","categories":[],"tags":[{"name":"Magic","slug":"Magic","permalink":"http://sarojaba.github.io/tags/Magic/"},{"name":"Marco Tempest","slug":"Marco-Tempest","permalink":"http://sarojaba.github.io/tags/Marco-Tempest/"},{"name":"Card","slug":"Card","permalink":"http://sarojaba.github.io/tags/Card/"},{"name":"TED","slug":"TED","permalink":"http://sarojaba.github.io/tags/TED/"}]},{"title":"jack-the-giant-slayer","slug":"jack-the-giant-slayer","date":"2013-06-09T07:21:00.000Z","updated":"2017-04-09T04:22:49.829Z","comments":true,"path":"2013/06/09/jack-the-giant-slayer/","link":"","permalink":"http://sarojaba.github.io/2013/06/09/jack-the-giant-slayer/","excerpt":"","text":"잭과 콩나무 이야기를 각색한 영화이다. 사실 원화의 내용은 기억나지 않기에 비교 불가능;; 중세 판타지를 배경으로 화끈한 액션이 볼만했다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Jack the Giant Slayer","slug":"Jack-the-Giant-Slayer","permalink":"http://sarojaba.github.io/tags/Jack-the-Giant-Slayer/"}]},{"title":"의뢰인","slug":"의뢰인","date":"2013-06-06T10:22:00.000Z","updated":"2017-04-09T04:23:33.928Z","comments":true,"path":"2013/06/06/의뢰인/","link":"","permalink":"http://sarojaba.github.io/2013/06/06/의뢰인/","excerpt":"","text":"아내를 죽인 살인용의자를 중심으로 검사와 변호사의 대립을 다룬 영화이다. 예전에 본 영화인데 기억이 안나서 다시 보았다. 하정우, 박희순, 장혁. 세 주연 배우들의 두뇌 싸움. 재미있었다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"의뢰인","slug":"의뢰인","permalink":"http://sarojaba.github.io/tags/의뢰인/"}]},{"title":"인류멸망보고서","slug":"인류멸망보고서","date":"2013-06-02T14:23:00.000Z","updated":"2017-04-09T04:23:58.680Z","comments":true,"path":"2013/06/02/인류멸망보고서/","link":"","permalink":"http://sarojaba.github.io/2013/06/02/인류멸망보고서/","excerpt":"","text":"인류가 멸망하는 세가지 가설을 옴니버스로 꾸민 영화이다. 흥행은 안되었지만 독특한 영화임에는 틀림없다. 깨알 배우들의 등장이 이 영화의 묘미인듯 ㅎ","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"인류멸망보고서","slug":"인류멸망보고서","permalink":"http://sarojaba.github.io/tags/인류멸망보고서/"}]},{"title":"신세계","slug":"신세계","date":"2013-05-29T15:31:00.000Z","updated":"2017-04-09T04:24:11.548Z","comments":true,"path":"2013/05/30/신세계/","link":"","permalink":"http://sarojaba.github.io/2013/05/30/신세계/","excerpt":"","text":"조폭으로 잠입한 경찰이 조폭 두목이 된다는 이야기. 꼬리를 무는 배신을 볼 수 있다. 처음부터 끝까지 재미있게 보았다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"신세계","slug":"신세계","permalink":"http://sarojaba.github.io/tags/신세계/"}]},{"title":"째째한-로맨스","slug":"째째한-로맨스","date":"2013-05-26T11:13:00.000Z","updated":"2017-04-09T04:29:23.390Z","comments":true,"path":"2013/05/26/째째한-로맨스/","link":"","permalink":"http://sarojaba.github.io/2013/05/26/째째한-로맨스/","excerpt":"","text":"남자 만화가와 여자 스토리 작가가 공모전을 준비하며 서로 연인이 되어간다는 이야기. 조금은 농도짙은 대사들이 나오지만 크게 거부감이 생기지는 않는다. 배우 최강희의 귀여운 매력이 보이는 영화였다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"째째한 로맨스","slug":"째째한-로맨스","permalink":"http://sarojaba.github.io/tags/째째한-로맨스/"}]},{"title":"진격의-거인","slug":"진격의-거인","date":"2013-05-26T08:59:00.000Z","updated":"2017-04-09T04:29:35.818Z","comments":true,"path":"2013/05/26/진격의-거인/","link":"","permalink":"http://sarojaba.github.io/2013/05/26/진격의-거인/","excerpt":"","text":"과거 거인들의 습격으로 스스로 벽을 쌓고 밖으로 나오지 않는 인류. 평화에 길들여진 인간들에게 다시 거인들이 습격을 하게 되는데&hellip; 친구의 추천으로 보게 되었는데 너무 재밌다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"진격의 거인","slug":"진격의-거인","permalink":"http://sarojaba.github.io/tags/진격의-거인/"}]},{"title":"나의-ps-파트너","slug":"나의-ps-파트너","date":"2013-05-12T09:29:00.000Z","updated":"2017-04-09T04:30:19.381Z","comments":true,"path":"2013/05/12/나의-ps-파트너/","link":"","permalink":"http://sarojaba.github.io/2013/05/12/나의-ps-파트너/","excerpt":"","text":"우연히 PS를 하게된 두 남녀를 중심으로 사랑과 이별에 대해 이야기하는 영화이다. 소재는 자극적이나 내용은 그리 자극적이지 않았다. 재밌게봤다 ㅎ","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"나의 PS 파트너","slug":"나의-PS-파트너","permalink":"http://sarojaba.github.io/tags/나의-PS-파트너/"}]},{"title":"enlightenment-17-설치하기","slug":"enlightenment-17-설치하기","date":"2013-05-11T15:34:00.000Z","updated":"2017-04-09T04:30:32.521Z","comments":true,"path":"2013/05/12/enlightenment-17-설치하기/","link":"","permalink":"http://sarojaba.github.io/2013/05/12/enlightenment-17-설치하기/","excerpt":"","text":"$ sudo add-apt-repository ppa:efl/trunk $ sudo apt-get update $ sudo apt-get install e17","categories":[],"tags":[{"name":"Enlightenment","slug":"Enlightenment","permalink":"http://sarojaba.github.io/tags/Enlightenment/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://sarojaba.github.io/tags/Ubuntu/"},{"name":"e17","slug":"e17","permalink":"http://sarojaba.github.io/tags/e17/"}]},{"title":"노리개","slug":"노리개","date":"2013-05-05T16:07:00.000Z","updated":"2017-04-09T05:28:54.670Z","comments":true,"path":"2013/05/06/노리개/","link":"","permalink":"http://sarojaba.github.io/2013/05/06/노리개/","excerpt":"","text":"연예계의 성상납에 대해 폭로하는 영화이다. 실제 이야기에 약간의 픽션만 추가했기에 실태의 심각성이 보는 내내 느껴졌다. &ldquo;스타가 되기 위해 저렇게 까지 해야할까?&rdquo; 라는 생각과 &ldquo;나는 목적을 위해 수단을 더럽히는 사람이 되어서는 안되겠다.&quot;라는 생각을 동시에 해본다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"노리개","slug":"노리개","permalink":"http://sarojaba.github.io/tags/노리개/"}]},{"title":"아이언맨3","slug":"아이언맨3","date":"2013-04-25T14:11:00.000Z","updated":"2017-04-09T05:30:38.817Z","comments":true,"path":"2013/04/25/아이언맨3/","link":"","permalink":"http://sarojaba.github.io/2013/04/25/아이언맨3/","excerpt":"","text":"슈퍼 히어로의 새로운 모델인 아이언맨. 3편이 개봉되었다. 영화관에서 4D로 봤는데 물튀고 의자 덜컹거리고. 근데 집중도는 떨어졌음. 암튼 기대만큼 재밌는 영화였다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"아이언맨3","slug":"아이언맨3","permalink":"http://sarojaba.github.io/tags/아이언맨3/"}]},{"title":"악마는-프라다를-입는다","slug":"악마는-프라다를-입는다","date":"2013-04-14T05:52:00.000Z","updated":"2017-04-09T05:31:03.464Z","comments":true,"path":"2013/04/14/악마는-프라다를-입는다/","link":"","permalink":"http://sarojaba.github.io/2013/04/14/악마는-프라다를-입는다/","excerpt":"","text":"기자를 꿈꾸는 여주인공이 패션계의 거물의 비서로 들어간다. 성공을 위해 가치관과 다르게 변화되는 자신의 모습을 보고 깨닫게 된다. 다시 꿈을 이루기 위해 처음부터 시작하는 내용의 영화이다. 뉴욕의 생활과 패션을 중점적으로 볼 수 있는 영화이다. 개인적으로 주인공인 앤 해서웨이가 이쁘게 나와서 더욱 재밌게 봤다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"java-8-에서-collection-다루기","slug":"java-8-에서-collection-다루기","date":"2013-04-13T03:29:00.000Z","updated":"2017-04-09T05:31:22.648Z","comments":true,"path":"2013/04/13/java-8-에서-collection-다루기/","link":"","permalink":"http://sarojaba.github.io/2013/04/13/java-8-에서-collection-다루기/","excerpt":"","text":"Java 8 문법의 가장 큰 변화는 람다라고 볼 수 있다. 람다를 이용하면 컬렉션의 각 요소들을 쉽게 다룰 수 있다. 컬렉션에 람다를 이용하기 위해 스트림이라는 인터페이스가 추가되었다. 컬렉션을 스트림으로 변환하기 위해 Collection 인터페이스의 stream() 이라는 메소드가 추가되었다. 스트림으로 변환 후 요소들을 다루는 메소드들로 변형을 한 뒤 다시 컬렉션으로 변환해주면 된다. Stream 인터페이스의 collect() 메소드를 사용하여 스트림에서 켈력션으로 변환한다. collect() 메소드의 인자로는 결과가 수집될 방법을 정의하는 Collector 객체를 넣는다. 위 과정을 코드로 나타내었다. List&lt;String&gt; result = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;) .stream() .map(s -&gt; &quot;Hello &quot; + s) .collect(Collectors.toList()); // result will be a List&lt;String&gt; containing &quot;Hello Larry&quot;, &quot;Hello Moe&quot; and &quot;Hello Curly&quot;","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Stream","slug":"Stream","permalink":"http://sarojaba.github.io/tags/Stream/"},{"name":"Collection","slug":"Collection","permalink":"http://sarojaba.github.io/tags/Collection/"}]},{"title":"1-introduction","slug":"1-introduction","date":"2013-04-12T13:34:00.000Z","updated":"2017-04-09T05:31:56.303Z","comments":true,"path":"2013/04/12/1-introduction/","link":"","permalink":"http://sarojaba.github.io/2013/04/12/1-introduction/","excerpt":"","text":"이 문서는 Rust 프로그래밍 언어를 위한 레퍼런스 매뉴얼이다. 다음의 세 종류의 단원을 제공한다. 언어 문법과 각 구조를 형식적으로 정의하고, 의미와 사용 예를 자유롭게 서술한 단원 메모리 모델, 동시성 모델, 런타임 서비스, 링킹 모델과 디버깅 도구를 자유롭게 서술한 단원 논리적 근거와 설계에 영향을 미친 언어를 참조하는 부록 단원 이 문서는 언어의 튜토리얼을 제공하지 않는다. 언어가 배경적으로 친숙하다고 가정한다. 분리된 튜토리얼 문서는 배경적 친밀도를 얻도록 도와준다. 이 문서는 언어 배포판에 포함되어 있는 core, standard 라이브러리의 참조를 제공하지 않는다. 이 라이브러리들은 소스 코드의 문서화 속성들에서 추출하여 따로 문서화된다.","categories":[],"tags":[{"name":"Rust","slug":"Rust","permalink":"http://sarojaba.github.io/tags/Rust/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"고양이를-빌려드립니다","slug":"고양이를-빌려드립니다","date":"2013-04-07T12:06:00.000Z","updated":"2017-04-09T05:32:10.351Z","comments":true,"path":"2013/04/07/고양이를-빌려드립니다/","link":"","permalink":"http://sarojaba.github.io/2013/04/07/고양이를-빌려드립니다/","excerpt":"","text":"주인공이 외로운 사람들에게 고양이를 빌려주고, 고양이로 인해 외로움을 치유해가는 이야기이다. 오랜만에 가슴 따뜻해지는 영화를 본것같아 기분이 좋다. 요즘 외롭다는 생각을 많이 했는데, 고양이를 키우고 싶은 마음이 생기게 하는 그런 작품이다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"cd-manipulation-한설희-le-plus-grand-cabaret-du","slug":"cd-manipulation-한설희-le-plus-grand-cabaret-du","date":"2013-04-06T13:12:00.000Z","updated":"2017-04-09T05:32:25.739Z","comments":true,"path":"2013/04/06/cd-manipulation-한설희-le-plus-grand-cabaret-du/","link":"","permalink":"http://sarojaba.github.io/2013/04/06/cd-manipulation-한설희-le-plus-grand-cabaret-du/","excerpt":"","text":"한설희 마술사의 CD Manipulation 공연 영상이다. 관객이 잠깐이라도 눈을 깜빡이면 CD 가 바뀌는 현상을 놓치게 될 정도로 빠른 템포로 진행한다. 기교의 끝을 보여주고 연습량도 엄청날 것 같은 대단한 액트이다.","categories":[],"tags":[{"name":"Magic","slug":"Magic","permalink":"http://sarojaba.github.io/tags/Magic/"},{"name":"한설희","slug":"한설희","permalink":"http://sarojaba.github.io/tags/한설희/"}]},{"title":"존재하지-않는-객체-다루기","slug":"존재하지-않는-객체-다루기","date":"2013-04-06T12:33:00.000Z","updated":"2017-04-09T05:32:41.535Z","comments":true,"path":"2013/04/06/존재하지-않는-객체-다루기/","link":"","permalink":"http://sarojaba.github.io/2013/04/06/존재하지-않는-객체-다루기/","excerpt":"","text":"명령줄로부터 이름을 입력받자. 명령줄에 아무것도 명시되지 않은 경우를 설명해야한다. 우리에게 Ceylon 에서 어떻게 null 값이 처리되는지 탐구할 수 있는 기회를 준 것이다. 아마도 Java 나 C# 에서 사용되는 것과 꽤 다를 것이다. 여기 지나치게 장황한 예제를 살펴보자. &quot;Print a personalized greeting&quot; void hello() { String? name = process.arguments.first; String greeting; if (exists name) { greeting = &quot;Hello, ``name``!&quot;; } else { greeting = &quot;Hello, World!&quot;; } print(greeting); } `&lt;/pre&gt; `String?` 타입은 `name` 이 `null` 값을 가질 수 있다는 것을 가리킨다. 그러면 이름이 ‘null’ 이 아닌 경우로부터 이름이 `null` 인 경우를 분리하기 위해 `if (exists ...)` 제어 구문을 사용한다. 아래처럼 `if (exist ...)` 제어 구문안에 지역 변수 `name` 을 선언하여 코드를 축약하는 것은 가능하다. &lt;pre&gt;`String greeting; if (exists name = process.arguments.first) { greeting = &quot;Hello, ``name``!&quot;; } else { greeting = &quot;Hello, World!&quot;; } print(greeting); if (exist ...) 구문 밖에서 유용하게 name 을 실제로 사용할 수 없기 때문에, 이 것은 대부분 경우에 선호되는 스타일이다. (그러나 이렇게해도 코드 작성하는 것은 거의 줄어들지 않는다.)","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"}]},{"title":"문자열-끼워넣기와-연결하기","slug":"문자열-끼워넣기와-연결하기","date":"2013-04-02T14:25:00.000Z","updated":"2017-04-09T05:33:15.038Z","comments":true,"path":"2013/04/02/문자열-끼워넣기와-연결하기/","link":"","permalink":"http://sarojaba.github.io/2013/04/02/문자열-끼워넣기와-연결하기/","excerpt":"","text":"우리 프로그램에게 자신에 대해 좀 더 이야기 하도록 만들자. &quot;The Hello World program ... version 1.1!&quot; void hello() { print(&quot;Hello, this is Ceylon ``language.version`` running on Java ``process.vmVersion``!\\n You ran me at ``process.milliseconds`` ms, with ``process.arguments.size`` arguments.&quot;); } `&lt;/pre&gt; 우리의 메시지에 문장들이 어떻게 삽입되었는지 보면, 더블백 “ 즉, 두개의 backtick 을 이용해 구분하였다. 이를 문자열 템플릿이라고 부른다. 필자의 컴퓨터에서 이 프로그램은 다음과 같은 결과를 출력하였다. &lt;pre&gt;`Hello, this is Ceylon 0.5 running on Java 1.7! You ran me at 1362763185067 ms, with 0 arguments. `&lt;/pre&gt; 다른 방법으로 + 연산자를 사용해 문자열을 이어붙히는 것도 가능하고, 이는 많은 경우에 더 유연하다. &lt;pre&gt;`print(&quot;Hello, this is Ceylon &quot; + language.version + &quot;running on Java &quot; + process.vmVersion + &quot;!\\n&quot; + &quot;You ran me at &quot; + process.milliseconds.string + &quot; ms, with &quot; + process.arguments.size.string + &quot; arguments.&quot;); 연산자를 이용해 문자열을 연결할 때, 명시적으로 string 속성을 호출해 숫자 표현을 문자로 변경해야 한다. + 연산자는 피연산자를 문자열로 자동적으로 변경하지 않는다. print(&quot;Hello, this is Ceylon &rdquo; + language.version + &ldquo;running on Java &rdquo; + process.vmVersion + &ldquo;!\\n&rdquo; + &ldquo;You ran me at &rdquo; + process.milliseconds + //compile error! &ldquo; ms, with &rdquo; + process.arguments.size + //compile error! &ldquo; arguments.&rdquo;);","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"},{"name":"String","slug":"String","permalink":"http://sarojaba.github.io/tags/String/"}]},{"title":"문자열-그대로-유지하기","slug":"문자열-그대로-유지하기","date":"2013-04-01T12:02:00.000Z","updated":"2017-04-09T05:33:49.702Z","comments":true,"path":"2013/04/01/문자열-그대로-유지하기/","link":"","permalink":"http://sarojaba.github.io/2013/04/01/문자열-그대로-유지하기/","excerpt":"","text":"문자열 리터럴에 코드를 삽입하는 것처럼 때로는 이스케이프 문자열을 넣는 것이 성가실 때가 있다. 만약 문자열 양 끝에 세개의 큰 따옴표 &ldquo;&rdquo;&ldquo; 를 사용하면 보이는 그대로의 문자열을 얻을 수 있다. 이스케이프 안되는 백슬러시와 큰 따옴표도 포함할 수 있다. print(&quot;&quot;&quot;&quot;Hello!&quot;, said the program.&quot;&quot;&quot;);","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"},{"name":"String","slug":"String","permalink":"http://sarojaba.github.io/tags/String/"}]},{"title":"이스케이프-문자","slug":"이스케이프-문자","date":"2013-04-01T11:44:00.000Z","updated":"2017-04-09T05:35:12.013Z","comments":true,"path":"2013/04/01/이스케이프-문자/","link":"","permalink":"http://sarojaba.github.io/2013/04/01/이스케이프-문자/","excerpt":"","text":"문자열 리터럴 안에 다른 C-like 언어들에서 사용되는 \\n, \\t, \\, “ 등의 이스케이프 문자를 사용할 수 있다. print(&quot;\\&quot;Hello!\\&quot;, said the program.&quot;); `&lt;/pre&gt; 텍스트에서 유니코드를 표현하기 위해 2 바이트와 4 바이트 16진수 이스케이프 문자도 사용할 수 있다. &lt;pre&gt;`&quot;The mathematical constant \\{#03C0}, the ratio of the circumference of a circle to its diameter.&quot; Float pi=calculatePi(); &quot;The mathematical constant \\{#0001D452}, the base of the natural logarithm.&quot; Float e=calculateE(); Ceylon의 문자열은 UTF-32 문자로 구성된다. 나중에 살펴볼 것이다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"},{"name":"String","slug":"String","permalink":"http://sarojaba.github.io/tags/String/"},{"name":"Escape Sequence","slug":"Escape-Sequence","permalink":"http://sarojaba.github.io/tags/Escape-Sequence/"}]},{"title":"robots","slug":"robots","date":"2013-03-31T14:11:00.000Z","updated":"2017-04-09T05:35:28.996Z","comments":true,"path":"2013/03/31/robots/","link":"","permalink":"http://sarojaba.github.io/2013/03/31/robots/","excerpt":"","text":"사내 아이라면 누구나 로봇 장난감을 가지고 놀 것이고 한번쯤은 로봇 과학자를 꿈꾸게 된다. 나 또한 그런 시절이 있었고 아직도 그 로망이 남아있다. 개인적으로 애니메이션 영화를 좋아해 재밌게 봤다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"Robots","slug":"Robots","permalink":"http://sarojaba.github.io/tags/Robots/"}]},{"title":"인라인-문서-포맷팅하기","slug":"인라인-문서-포맷팅하기","date":"2013-03-31T01:38:00.000Z","updated":"2017-04-09T05:35:49.176Z","comments":true,"path":"2013/03/31/인라인-문서-포맷팅하기/","link":"","permalink":"http://sarojaba.github.io/2013/03/31/인라인-문서-포맷팅하기/","excerpt":"","text":"doc 어노테이션은 Markdown 포맷을 포함할 수 있다. &quot;The classic [Hello World program][helloworld] that prints a message to the console, this time written in [Ceylon][]. This simple program demonstrates: 1. how to define a toplevel function, and 2. how to `print()` a literal `String`. You can compile and run `hello()` from the command line like this: ceylon compile source/hello.ceylon ceylon run -run hello default Or you can use `Run As &gt; Ceylon Application` in the IDE. [helloworld]: [http://en.wikipedia.org/wiki/Hello_world_program](http://en.wikipedia.org/wiki/Hello_world_program) [Ceylon]: [http://ceylon-lang.org](http://ceylon-lang.org)&quot; void hello() { print(&quot;Hello, World!&quot;); } Markdown 은 텍스트가 나타나는 초기 컬럼에 민감하기 때문에 여러줄 리터럴의 들여쓰기를 정확히 하도록 신경써야 한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"},{"name":"Markdown","slug":"Markdown","permalink":"http://sarojaba.github.io/tags/Markdown/"}]},{"title":"광해-왕이-된-남자-연극","slug":"광해-왕이-된-남자-연극","date":"2013-03-30T13:59:00.000Z","updated":"2017-04-09T05:39:45.049Z","comments":true,"path":"2013/03/30/광해-왕이-된-남자-연극/","link":"","permalink":"http://sarojaba.github.io/2013/03/30/광해-왕이-된-남자-연극/","excerpt":"","text":"친구가 급한 볼일이 생겨 대신 연극을 보러 갔다. 영화 광해를 연극으로 옮긴 작품이고, 배우 배수빈이 주연으로 열연을 펼쳤다. 너무 재밌게 봤고, 영화도 얼른 봐야겠다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"광해","slug":"광해","permalink":"http://sarojaba.github.io/tags/광해/"}]},{"title":"인라인-문서-추가하기","slug":"인라인-문서-추가하기","date":"2013-03-30T13:19:00.000Z","updated":"2017-04-09T05:40:18.788Z","comments":true,"path":"2013/03/30/인라인-문서-추가하기/","link":"","permalink":"http://sarojaba.github.io/2013/03/30/인라인-문서-추가하기/","excerpt":"","text":"대부분의 경우 hello() 와 같은 중요한 함수에 어떤 종류의 문서를 추가하는 것은 좋은 생각이다. 한가지 방법은 다음과 같이 C 스타일의 주석을 사용하는 것이다. /* The classic Hello World program */ void hello() { print(&quot;Hello, World!&quot;); } `&lt;/pre&gt; 또는 &lt;pre&gt;`//The classic Hello World program void hello() { print(&quot;Hello, World!&quot;); } `&lt;/pre&gt; 그러나 정의를 기술하기 위한 주석으로 doc 어노테이션을 사용하는 것이 더 낫다. &lt;pre&gt;`doc (&quot;The classic Hello World program&quot;) by (&quot;Gavin&quot;) see (goodbye) throws (IOException) void hello() { print(&quot;Hello, World!&quot;); } `&lt;/pre&gt; doc, by, see, throws, tagged 어노테이션은 Ceylon 문서화 컴파일러인 ceylon doc 의 출력에 포함될 내용을 가진다. doc, by, see, throws 와 같은 어노테이션은 키워드가 아니다. 그냥 평범한 식별자이다. abstract, variable, shared, formal, default, actual 등의 언어 정의의 한 부분인 어노테이션들도 마찬가지다.(반면에, void 는 C 나 Java 처럼 키워드이다.) doc 어노테이션은 어디에나 존재할 수 있기 때문에, 프로그램 요소의 어노테이션 목록에서 첫번째 어노테이션에 위치하면 이름과 괄호를 생략할 수 있다 &lt;pre&gt;`&quot;The classic Hello World program&quot; by (&quot;Gavin&quot;) see (goodbye) throws (IOException) void hello() { print(&quot;Hello, World!&quot;); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"},{"name":"Documentation","slug":"Documentation","permalink":"http://sarojaba.github.io/tags/Documentation/"}]},{"title":"문자열-리터럴","slug":"문자열-리터럴","date":"2013-03-29T13:50:00.000Z","updated":"2017-04-09T05:41:03.380Z","comments":true,"path":"2013/03/29/문자열-리터럴/","link":"","permalink":"http://sarojaba.github.io/2013/03/29/문자열-리터럴/","excerpt":"","text":"이미 본 것처럼, 문자열 리터럴은 큰따옴표 사이에 들어있는 텍스트이다. void hello() { print(&quot;Hello, World!&quot;); } `&lt;/pre&gt; Ceylon 의 문자열 리터럴은 여러줄로 나눌 수 있다. &lt;pre&gt;`void hello() { print(&quot;Hello, World!&quot;); } `&lt;/pre&gt; 출력은 다음과 같다. &lt;pre&gt;`Hello, World! `&lt;/pre&gt; 문자열 리터럴의 두번째 줄이 가지고 있는 문자열 리터럴의 첫번째 줄의 첫번째 문자까지의 공백은 자동적으로 제거된다. 이는 코드가 멋지게 포맷되도록 한다. 여러줄 문자열 리터럴에서 공백을 제거하는 것은 자주 유용하다. String 클래스는 normalized 라는 속성을 가진다. 다음과 같이 사용할 수 있다. &lt;pre&gt;`void hello() { value message = &quot;Hello, World!&quot;; print(message.normalized); } `&lt;/pre&gt; 출력 결과는 다음과 같다. &lt;pre&gt;`Hello, World! 여러줄 문자열은 프로그램에 문서를 추가할 때 특히 유용하다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"},{"name":"String","slug":"String","permalink":"http://sarojaba.github.io/tags/String/"}]},{"title":"서툰-사람들","slug":"서툰-사람들","date":"2013-03-29T13:16:00.000Z","updated":"2017-04-09T05:41:34.143Z","comments":true,"path":"2013/03/29/서툰-사람들/","link":"","permalink":"http://sarojaba.github.io/2013/03/29/서툰-사람들/","excerpt":"","text":"회사에서 단체로 연극을 관람했다. 제목은 &lt;서툰 사람들&gt; 이다. 대학 신입생때 부산에서 본 연극이었다. 보면서 조금씩 기억이 떠올랐다. 배우의 표정 연기나 대사가 아니라 연극의 상황 자체에 웃을 수 있는 그런 작품이었다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"},{"name":"서툰 사람들","slug":"서툰-사람들","permalink":"http://sarojaba.github.io/tags/서툰-사람들/"}]},{"title":"커맨드-라인에서-프로그램-실행하기","slug":"커맨드-라인에서-프로그램-실행하기","date":"2013-03-29T12:14:00.000Z","updated":"2017-04-09T05:42:10.335Z","comments":true,"path":"2013/03/29/커맨드-라인에서-프로그램-실행하기/","link":"","permalink":"http://sarojaba.github.io/2013/03/29/커맨드-라인에서-프로그램-실행하기/","excerpt":"","text":"한번 해보자. 위 코드를 ./source/hello.ceylon 으로 저장하고 아래의 명령을 수행하라. ceylon-0.5/bin/ceylon compile source/hello.ceylon ceylon-0.5/bin/ceylon run --run hello default `&lt;/pre&gt; ceylon-0.5 는 Ceylon 이 설치된 디렉토리의 경로이다. Hello, World! 라는 메시지를 볼 수 있을 것이다. ./modules/default 디렉토리에 default.car 라는 컴파일된 모듈 아카이브가 있을 것이다. 다음은 아주 유용한 트릭이다. &lt;pre&gt;`ceylon-0.5/bin/ceylon help compile ceylon-0.5/bin/ceylon help run `&lt;/pre&gt; ceylon help 명령은 ceylon 서브명령에 대한 사용 정보를 출력한다. 만약 커맨드 라인 툴을 시작하는데 문제가 있다면 예제 컴파일과 실행을 해보자. ## JDK 선택하기 Ceylon 은 Java 7 이 필요하기 때문에 사용하고 있는 Java 버전이 맞는지 확인할 필요가 있다. &lt;pre&gt;`bash$ java -version java version &quot;1.7.0_05&quot; Java(TM) SE Runtime Environment (build 1.7.0_05-b06) Java HotSpot(TM) 64-Bit Server VM (build 23.1-b03, mixed mode) bash$ javac -version javac 1.7.0_05 `&lt;/pre&gt; 만약 다른 버전의 Java 를 사용하고 있다면, Java 7 로 변경해야 한다. Linux 에서는 update-java-alternatives 를 사용한다. Mac 에서는 System Preferences applet 를 이용한다. Windows 에서는 JAVA-HOME 환경 변수를 설정한다. 문자 인코딩 설정하기만약 Ceylon 프로그램을 컴파일 하는 중에 다음의 에러나 비슷한 것을 본다면 `unmappable character for encoding ASCII ` 소스 파일의 인코딩과 OS 의 기본 문자 인코딩이 일치하지 않는 것이다. 아래와 같은 명령줄로 문자 인코딩을 명시적으로 정해야 한다. `ceylon compile –encoding UTF-8 source/hello.ceylon","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"}]},{"title":"a-really-simple-program","slug":"a-really-simple-program","date":"2013-03-28T21:16:00.000Z","updated":"2017-04-09T05:42:57.622Z","comments":true,"path":"2013/03/29/a-really-simple-program/","link":"","permalink":"http://sarojaba.github.io/2013/03/29/a-really-simple-program/","excerpt":"","text":"여기 고전적인 예제 프로그램이 있다. void hello() { print(&quot;Hello, World!&quot;); } `&lt;/pre&gt; 이 함수는 Hello, World! 를 콘솔에 찍는다. 어떤 타입의 멤버도 아니기 때문에 이 함수를 최상위 레벨 함수라고 부른다. 최상위 레벨 함수를 호출하기 위해 객체를 받을 필요가 없다. 대신에 다음처럼 호출만 하면 된다. &lt;pre&gt;`hello(); `&lt;/pre&gt; Ceylon 은 Java, C++, C# 에서 볼 수 있는 static 메소드를 가지지 않지만 최상위 레벨 함수가 같은 역할을 하고 있다고 보면 된다. 이렇게 차이가 나는 이유는 Ceylon 은 아주 엄격한 블록 구조를 가지고 있기 때문이다. 중첩된 블록은 포함하는 블록의 선언에 항상 접근할 수 있다. Java 의 static 메소드의 경우와는 다르다. Ceylon 은 아직 스크립팅을 지원하지 않는다. 함수나 클래스 밖에서 print(“Hello World!”); 라고만 적는것은 안된다. 다음은 잘못된 프로그램이다. &lt;pre&gt;`print(&quot;Hello, World!&quot;); //error: must occur inside a function or class","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Ceylon","slug":"Ceylon","permalink":"http://sarojaba.github.io/tags/Ceylon/"}]},{"title":"another-earth","slug":"another-earth","date":"2013-03-16T13:11:00.000Z","updated":"2017-04-09T05:43:20.997Z","comments":true,"path":"2013/03/16/another-earth/","link":"","permalink":"http://sarojaba.github.io/2013/03/16/another-earth/","excerpt":"","text":"한순간의 실수로 교통사고를 내고 살인자가 된 주인공이 스스로를 용서해가는 과정을 그린 영화이다. 영화내내 스릴러같은 분위기를 낸다. 재미있지는 않다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"ubuntu-에-enlightenment-e17-설치하기","slug":"ubuntu-에-enlightenment-e17-설치하기","date":"2013-03-13T16:32:00.000Z","updated":"2017-04-09T05:43:42.677Z","comments":true,"path":"2013/03/14/ubuntu-에-enlightenment-e17-설치하기/","link":"","permalink":"http://sarojaba.github.io/2013/03/14/ubuntu-에-enlightenment-e17-설치하기/","excerpt":"","text":"sudo apt-add-repository ppa:hannes-janetzek/enlightenment-svn sudo apt-get update sudo apt-get install e17","categories":[],"tags":[{"name":"Enlightenment","slug":"Enlightenment","permalink":"http://sarojaba.github.io/tags/Enlightenment/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://sarojaba.github.io/tags/Ubuntu/"},{"name":"Linux","slug":"Linux","permalink":"http://sarojaba.github.io/tags/Linux/"}]},{"title":"ubuntu-에-sublime-text-설치하기","slug":"ubuntu-에-sublime-text-설치하기","date":"2013-03-10T12:39:00.000Z","updated":"2017-04-09T05:43:57.457Z","comments":true,"path":"2013/03/10/ubuntu-에-sublime-text-설치하기/","link":"","permalink":"http://sarojaba.github.io/2013/03/10/ubuntu-에-sublime-text-설치하기/","excerpt":"","text":"$ sudo add-apt-repository ppa:webupd8team/sublime-text-2 $ sudo apt-get update $ sudo apt-get install sublime-text","categories":[],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://sarojaba.github.io/tags/Linux/"},{"name":"Sublime Text","slug":"Sublime-Text","permalink":"http://sarojaba.github.io/tags/Sublime-Text/"}]},{"title":"ubuntu-1104-에서-마우스-휠-속도가-너무-빨라요","slug":"ubuntu-1104-에서-마우스-휠-속도가-너무-빨라요","date":"2013-02-26T11:25:00.000Z","updated":"2017-04-09T05:44:15.057Z","comments":true,"path":"2013/02/26/ubuntu-1104-에서-마우스-휠-속도가-너무-빨라요/","link":"","permalink":"http://sarojaba.github.io/2013/02/26/ubuntu-1104-에서-마우스-휠-속도가-너무-빨라요/","excerpt":"","text":"마우스를 연결 해제하고 다시 연결하면 된다.","categories":[],"tags":[{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://sarojaba.github.io/tags/Ubuntu/"}]},{"title":"the-quck-change-show-movie-theme-from-korea","slug":"the-quck-change-show-movie-theme-from-korea","date":"2013-02-18T12:50:00.000Z","updated":"2017-04-09T05:44:36.964Z","comments":true,"path":"2013/02/18/the-quck-change-show-movie-theme-from-korea/","link":"","permalink":"http://sarojaba.github.io/2013/02/18/the-quck-change-show-movie-theme-from-korea/","excerpt":"","text":"나의 리즈 시절&hellip; 같이 마술하던 동생이 엄청난 마술사가 되어 돌아왔다. 처음부터 그 싹이 보이긴 했지만 그동안 얼마나 힘든 과정을 겪었을까? 자랑스럽고 대견하다. 현민아! 화이팅!! 세계 최고의 마술사가 되거라!!","categories":[],"tags":[{"name":"Magic","slug":"Magic","permalink":"http://sarojaba.github.io/tags/Magic/"}]},{"title":"짝패","slug":"짝패","date":"2013-02-15T14:54:00.000Z","updated":"2017-04-09T05:44:57.800Z","comments":true,"path":"2013/02/15/짝패/","link":"","permalink":"http://sarojaba.github.io/2013/02/15/짝패/","excerpt":"","text":"류승완 감독과 정두홍 무술감독이 주연인 한국식 르와르 액션 영화. 친구들의 우정과 배신이 스토리의 전부이다. 중간중간 연기가 어색한 부분도 있지만 액션만큼은 사실적이고 화려하다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"devkit","slug":"devkit","date":"2013-02-15T12:20:00.000Z","updated":"2017-04-09T05:45:52.187Z","comments":true,"path":"2013/02/15/devkit/","link":"","permalink":"http://sarojaba.github.io/2013/02/15/devkit/","excerpt":"","text":"HTML5 2D 게임 개발 엔진이다. 데모 영상만 봐서는 뭔가 대단하다. 시간나면 이걸로 뭔가 만들어봐야겠다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Web","slug":"Web","permalink":"http://sarojaba.github.io/tags/Web/"},{"name":"Mobile","slug":"Mobile","permalink":"http://sarojaba.github.io/tags/Mobile/"}]},{"title":"boggle","slug":"boggle","date":"2013-02-14T13:26:00.000Z","updated":"2017-04-09T05:48:00.813Z","comments":true,"path":"2013/02/14/boggle/","link":"","permalink":"http://sarojaba.github.io/2013/02/14/boggle/","excerpt":"","text":"Problemhttp://algospot.com/judge/problem/read/BOGGLE Source Codepackage com.sarojaba.algospot; import java.util.Scanner; /** * [http://algospot.com/judge/problem/read/BOGGLE](http://algospot.com/judge/problem/read/BOGGLE) * * @author 준혁 * */ public class BOGGLE { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // test case int C = Integer.parseInt(scanner.nextLine()); for (int i = 0; i &lt; C; i++) { // board Board b = new Board(5, 5); for (int j = 0; j &lt; 5; j++) { String line = scanner.nextLine(); for (int k = 0; k &lt; 5; k++) { b.set(j, k, line.charAt(k)); } } // words int N = Integer.parseInt(scanner.nextLine()); for (int j = 0; j &lt; N; j++) { String line = scanner.nextLine(); String yn = b.search(line) ? &quot;YES&quot; : &quot;NO&quot;; System.out.println(String.format(&quot;%s %s&quot;, line, yn)); } } scanner.close(); } } /** * implementation of boggle board * * @author 준혁 * */ class Board { /** * board */ private char[][] board; /** * constructor * * @param r * row * @param c * col */ public Board(int r, int c) { board = new char[r][c]; } /** * setter * * @param r * index of row * @param c * index of column * @param value */ public void set(int r, int c, char value) { board[r][c] = value; } /** * exhaustive search * * @param word * @return match */ public boolean search(String word) { for (int i = 0; i &lt; board.length; i++) { for (int j = 0; j &lt; board[i].length; j++) { if (search(i, j, word)) { return true; } } } return false; } /** * * @param r * row * @param c * col * @param word * @return match */ private boolean search(int r, int c, String word) { // match if (word.isEmpty()) { return true; } // out of bound if (r &lt; 0 || r &gt; board.length - 1) { return false; } if (c &lt; 0 || c &gt; board[r].length - 1) { return false; } // not match if (board[r][c] != word.charAt(0)) { return false; } // recursive search String w = word.substring(1); for (int i = -1; i &lt;= 1; i++) { for (int j = -1; j &lt;= 1; j++) { if(i == 0 &amp;&amp; j == 0) { continue; } if (search(r + i, c + j, w)) { return true; } } } return false; } } Comment샘플 케이스만 만족시킨 답안이다. 완전 탐색이라 시간 초과에 걸린다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"flight","slug":"flight","date":"2013-02-13T12:21:00.000Z","updated":"2017-04-09T05:48:23.013Z","comments":true,"path":"2013/02/13/flight/","link":"","permalink":"http://sarojaba.github.io/2013/02/13/flight/","excerpt":"","text":"불가항력의 위급 상황에서 기지를 발휘하여 기적적으로 대부분의 승객을 구한 비행사. 하지만 그는 비행 전 음주를 한 사실이 발각되었다. 우리는 그를 영웅이라고 해야할까? 죄인이라고 해야할까? 진실과 거짓이 사이에서 갈등하는 주인공의 모습이 잘 묘사된 영화이다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"7번방의-선물","slug":"7번방의-선물","date":"2013-02-11T16:31:00.000Z","updated":"2017-04-09T05:48:39.105Z","comments":true,"path":"2013/02/12/7번방의-선물/","link":"","permalink":"http://sarojaba.github.io/2013/02/12/7번방의-선물/","excerpt":"","text":"어린 아이의 지능을 가진 아버지가 누명을 쓰고, 교도소에서 벌어지는 이야기를 담았다. 아버지가 딸을 애타게 부르는 장면에서 눈물이 났다. 가슴 찡한 부성애를 느낄 수 있었다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"정리-못하는-정리베","slug":"정리-못하는-정리베","date":"2013-02-04T10:56:00.000Z","updated":"2017-04-09T05:49:08.184Z","comments":true,"path":"2013/02/04/정리-못하는-정리베/","link":"","permalink":"http://sarojaba.github.io/2013/02/04/정리-못하는-정리베/","excerpt":"","text":"문제알고스팟 새싹 콘테스트를 준비하느라 정신이 없던 정리베는, 버벅거리는 컴퓨터의 원인이 가득 찬 하드디스크라는 것을 알게 되었습니다. 하드의 파일들을 확인해본 후, 정리베는 두 가지 사실을 발견했습니다. 하드 용량의 대부분을 MP3파일이 차지한다. MP3파일 중에 중복되는 파일이 존재한다. 따라서 정리베는 MP3파일들을 정리하여 하드 공간을 어느 정도 더 확보할 수 있는지 알아보려고 합니다. 모든 MP3파일의 이름은 다음과 같은 형식으로 쓰여집니다. 이를 통해 MP3파일에 해당하는 아티스트 명과 곡의 제목을 알 수 있으며, 아티스트 명과 곡의 제목이 같을 경우 이를 동일한 곡으로 간주합니다. (트랙 번호)(아티스트 명)(곡 제목).mp3 (트랙 번호). (아티스트 명) - (곡 제목).mp3 (아티스트 명) - (곡 제목).mp3 (아티스트 명)_(곡 제목).mp3 (트랙 번호)는 0부터 9까지의 숫자 조합으로 이루어지고, (아티스트 명)과 (곡 제목)은 공백, 숫자, 영문자 그리고 여는 괄호 &rsquo;(&lsquo;와 닫는 괄호 &rsquo;)&rsquo; 문자의 조합으로 이뤄집니다. 모든 파일은 위 4가지 중 한 가지 형식으로만 해석될 수 있습니다. (아티스트 명)과 (곡 제목) 비교시에 알파벳 대소문자는 구분하지 않습니다. 입력입력의 첫 줄에는 곡의 개수 N이 입력됩니다. 그 후 N줄에 각각 파일의 경로가 주어지는데, 형식은 다음과 같습니다. (파일명) /(폴더1)/(폴더2)/&hellip;/(파일명) 2번째 형식의 경우 중첩된 폴더 구조에 위치한 파일을 의미합니다. 출력한 줄에 중복을 모두 제외한 곡의 개수를 출력합니다. 입력 파일A1.txt A2.txt 제약 조건예제 입력9 Above and Beyond Feat Zoe Johnston - Alchemy (Above and Beyond Club Mix).mp3 Coldplay - Every Teardrop Is A Waterfall (Swedish House Mafia Remix).mp3 /Andrew Rayel/Armin Van Buuren - Serenity (Andrew Rayel Aether Remix).mp3 Armin Van Buuren - Serenity (Andrew Rayel Aether Remix).mp3 /Above and Beyond Feat Zoe Johnston - Alchemy/Above and Beyond Feat Zoe Johnston - Alchemy (Above and Beyond Club Mix).mp3 Nuera - Transatlantic 2009 (Original Mix).mp3 /Discograph/Nuera/Nuera - Transatlantic 2011 (Original Mix).mp3 /Alex M O R P H - Eternal Flame (Alex M O R P H s Reach Out For The Stars Mix).mp3 01. Armin Van Buuren Feat Fiora - Waiting For The Night (Radio Edit).mp3 `&lt;/pre&gt; # 예제 출력 &lt;pre&gt;`7 `&lt;/pre&gt; # Source Code &lt;pre&gt;`package com.sarojaba.algospot.newbie; import java.io.File; import java.util.HashSet; import java.util.Scanner; import java.util.Set; import java.util.regex.Matcher; import java.util.regex.Pattern; public class A { public static void main(String[] args) throws Exception { Scanner scanner = new Scanner(new File(&quot;a.txt&quot;)); int N = scanner.nextInt(); String[] lines = new String[N]; for (int i = 0; i &lt; N; i++) { lines[i] = scanner.nextLine(); } System.out.println(solve(lines)); scanner.close(); } public static int solve(String[] lines) { Set mp3s = new HashSet&lt;&gt;(); Pattern pattern = Pattern.compile(&quot;(?:/.*)*/(.*)&quot;); for (String l : lines) { Matcher matcher = pattern.matcher(l); String f = l; if (matcher.matches()) { f = matcher.group(1); } mp3s.add(MP3.parse(f)); } return mp3s.size(); } } class MP3 { private String artist; private String song; private int track; public MP3(String artist, String song) { this(artist, song, 0); } public MP3(String artist, String song, int track) { this.artist = artist; this.song = song; this.track = track; } @Override public boolean equals(Object obj) { if (!(obj instanceof MP3)) { return false; } MP3 mp3 = (MP3) obj; if (!artist.equalsIgnoreCase(mp3.artist)) { return false; } if (!song.equalsIgnoreCase(mp3.song)) { return false; } return true; } @Override public int hashCode() { return (artist.toLowerCase().hashCode() + song.toLowerCase().hashCode()) % Integer.MAX_VALUE; } @Override public String toString() { return String.format(&quot;{artist: %s, song: %s}&quot;, artist, song); } public static MP3 parse(String file) { Pattern[] patterns = new Pattern[2]; patterns[0] = Pattern.compile(&quot;(.*)_(.*)_(.*)\\\\.mp3&quot;); patterns[1] = Pattern.compile(&quot;(.*)\\\\. (.*) - (.*)\\\\.mp3&quot;); for (Pattern p : patterns) { Matcher matcher = p.matcher(file); if (matcher.matches()) { try { int track = Integer.parseInt(matcher.group(1)); String artist = matcher.group(2); String song = matcher.group(3); return new MP3(artist, song, track); } catch (NumberFormatException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } patterns[0] = Pattern.compile(&quot;(.*) - (.*)\\\\.mp3&quot;); patterns[1] = Pattern.compile(&quot;(.*)_(.*)\\\\.mp3&quot;); for (Pattern p : patterns) { Matcher matcher = p.matcher(file); if (matcher.matches()) { String artist = matcher.group(1); String song = matcher.group(2); return new MP3(artist, song); } } return null; } }","categories":[],"tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://sarojaba.github.io/tags/Algorithm/"},{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"베를린","slug":"베를린","date":"2013-02-03T04:40:00.000Z","updated":"2017-04-09T05:50:16.827Z","comments":true,"path":"2013/02/03/베를린/","link":"","permalink":"http://sarojaba.github.io/2013/02/03/베를린/","excerpt":"","text":"하정우, 한석규, 전지현, 류승범&hellip; 캐스팅으로 주목받은 영화. 북한 정보 요원이 배신을 당해 복수하는 내용이다. 사실감있는 액션에 지루하지 않은 영화였다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"markdown","slug":"markdown","date":"2013-01-31T14:45:00.000Z","updated":"2017-04-09T05:53:04.563Z","comments":true,"path":"2013/01/31/markdown/","link":"","permalink":"http://sarojaba.github.io/2013/01/31/markdown/","excerpt":"","text":"HTML로 변환되는 텍스트 포맷. 작성이 쉽다는 장점이 있다. Tumblr는 기본적으로 Markdown을 지원한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"}]},{"title":"시리우스","slug":"시리우스","date":"2013-01-30T12:37:00.000Z","updated":"2017-04-09T05:53:24.876Z","comments":true,"path":"2013/01/30/시리우스/","link":"","permalink":"http://sarojaba.github.io/2013/01/30/시리우스/","excerpt":"","text":"쌍둥이 형재의 신분이 바뀌는 이야기이다. 배우 서준영과 류승수의 열연이 돋보이는 KBS 드라마. 요즘 드라마를 잘 보지 않는데 대박 작품 봐서 기분이 좋다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"내가-살인범이다","slug":"내가-살인범이다","date":"2013-01-27T06:37:00.000Z","updated":"2017-04-09T05:55:35.018Z","comments":true,"path":"2013/01/27/내가-살인범이다/","link":"","permalink":"http://sarojaba.github.io/2013/01/27/내가-살인범이다/","excerpt":"","text":"연쇄 살인범을 쫒는 형사의 이야기이다. 과연 공소시효가 만료된 살인범의 죄는 용서받을 수 있는가에 대한 물음을 던져주고 있다. 흥미로운 시나리오와 주연 배우들의 연기가 돋보이는 작품이다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"firefox-os-app-days","slug":"firefox-os-app-days","date":"2013-01-26T07:38:00.000Z","updated":"2017-04-09T05:55:50.862Z","comments":true,"path":"2013/01/26/firefox-os-app-days/","link":"","permalink":"http://sarojaba.github.io/2013/01/26/firefox-os-app-days/","excerpt":"","text":"모질라 커뮤니티 행사에 참석했다. 골방에 갇혀 발 번역 중 ㅋㅋ","categories":[],"tags":[{"name":"Firefox OS","slug":"Firefox-OS","permalink":"http://sarojaba.github.io/tags/Firefox-OS/"},{"name":"mozilla","slug":"mozilla","permalink":"http://sarojaba.github.io/tags/mozilla/"}]},{"title":"워스토리-for-kakao","slug":"워스토리-for-kakao","date":"2013-01-24T14:00:00.000Z","updated":"2017-04-09T05:56:04.550Z","comments":true,"path":"2013/01/24/워스토리-for-kakao/","link":"","permalink":"http://sarojaba.github.io/2013/01/24/워스토리-for-kakao/","excerpt":"","text":"요즘 하고있는 게임이다. 카카오 친구들과 협동하는 밀리터리 SNG. 은근 재밌는데 버그가 좀 있다. 갈굼당하고 있을 불쌍한 개발자들 ㅠ_ㅠ Google Play","categories":[],"tags":[{"name":"Game","slug":"Game","permalink":"http://sarojaba.github.io/tags/Game/"}]},{"title":"루돌프-사슴코-우쿨렐레-버전","slug":"루돌프-사슴코-우쿨렐레-버전","date":"2013-01-22T14:15:00.000Z","updated":"2017-04-09T05:56:18.807Z","comments":true,"path":"2013/01/22/루돌프-사슴코-우쿨렐레-버전/","link":"","permalink":"http://sarojaba.github.io/2013/01/22/루돌프-사슴코-우쿨렐레-버전/","excerpt":"","text":"크리스마스를 맞이하여 노래와 반주","categories":[],"tags":[{"name":"Ukulele","slug":"Ukulele","permalink":"http://sarojaba.github.io/tags/Ukulele/"}]},{"title":"2012","slug":"2012","date":"2013-01-19T14:49:00.000Z","updated":"2017-04-09T05:56:35.635Z","comments":true,"path":"2013/01/19/2012/","link":"","permalink":"http://sarojaba.github.io/2013/01/19/2012/","excerpt":"","text":"지금껏 본 재난 영화 중에 스케일이 가장 컸다. 엄청난 컴퓨터 그래픽과 훈훈한 가족애를 느낄 수 있었다. 2012년 세계는 멸망하지 않았고 지금 나는 블로깅을 하고 있다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"mobile-page-structure","slug":"mobile-page-structure","date":"2013-01-10T15:02:00.000Z","updated":"2017-04-09T05:58:03.192Z","comments":true,"path":"2013/01/11/mobile-page-structure/","link":"","permalink":"http://sarojaba.github.io/2013/01/11/mobile-page-structure/","excerpt":"","text":"Source Code &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;My Page&lt;/title&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;http://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.css&quot;&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/jquery-1.8.2.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://code.jquery.com/mobile/1.2.0/jquery.mobile-1.2.0.min.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt; 끝.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"jQuery","slug":"jQuery","permalink":"http://sarojaba.github.io/tags/jQuery/"},{"name":"jQuery Mobile","slug":"jQuery-Mobile","permalink":"http://sarojaba.github.io/tags/jQuery-Mobile/"}]},{"title":"factory-method-pattern","slug":"factory-method-pattern","date":"2013-01-09T16:13:00.000Z","updated":"2017-04-09T06:00:47.609Z","comments":true,"path":"2013/01/10/factory-method-pattern/","link":"","permalink":"http://sarojaba.github.io/2013/01/10/factory-method-pattern/","excerpt":"","text":"GOF의 Design Patterns에 나오는 생성 패턴이다. 주된 역할은 클라이언트는 객체를 직접 생성하지 않고 팩토리에게 위임한다. 팩토리는 메소드를 통해 객체를 생성한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Design Pattern","slug":"Design-Pattern","permalink":"http://sarojaba.github.io/tags/Design-Pattern/"},{"name":"Factory Method","slug":"Factory-Method","permalink":"http://sarojaba.github.io/tags/Factory-Method/"},{"name":"GOF","slug":"GOF","permalink":"http://sarojaba.github.io/tags/GOF/"}]},{"title":"firefox-os","slug":"firefox-os","date":"2012-12-18T17:00:00.000Z","updated":"2017-04-09T06:00:59.513Z","comments":true,"path":"2012/12/19/firefox-os/","link":"","permalink":"http://sarojaba.github.io/2012/12/19/firefox-os/","excerpt":"","text":"오픈 웹 기술을 이용해 모바일 개발을 하려는 목적을 실현하기 위해 모질라에서 개발된 운영체제이다. 원래 Boot to Gecko 라는 이름의 프로젝트로 시작하였고, 현재는 Firefox OS 라고 이름 지어졌다. 전체 스택은 커널과 HAL 영역을 포함하는 Gonk, 어플리케이션 런타임을 담당하는 Gecko, 유저 인터페이스를 담당하는 Gaia 로 나뉜다. HTML, CSS, Javascript 를 이용해 어플리케이션을 개발한다. http://www.mozilla.org/en-US/firefoxos/","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Firefox OS","slug":"Firefox-OS","permalink":"http://sarojaba.github.io/tags/Firefox-OS/"},{"name":"Mozilla","slug":"Mozilla","permalink":"http://sarojaba.github.io/tags/Mozilla/"},{"name":"HTML","slug":"HTML","permalink":"http://sarojaba.github.io/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"http://sarojaba.github.io/tags/CSS/"},{"name":"Javascript","slug":"Javascript","permalink":"http://sarojaba.github.io/tags/Javascript/"},{"name":"B2G","slug":"B2G","permalink":"http://sarojaba.github.io/tags/B2G/"}]},{"title":"javafx","slug":"javafx","date":"2012-11-26T12:49:00.000Z","updated":"2017-04-09T06:01:11.133Z","comments":true,"path":"2012/11/26/javafx/","link":"","permalink":"http://sarojaba.github.io/2012/11/26/javafx/","excerpt":"","text":"JavaFX는 RIA(Rich Internet Application)를 구현하기 위한 자바 UI 프레임워크이다. JavaFX 1.x는 실패하였으나 2.x는 JavaSE7u6에 포함되었고, 앞으로 Swing을 조금씩 대체해 나갈 것으로 보인다. 주요 특징으로는 FXML과 CSS를 통해 UI를 디자인하고, Scene Graph를 통해 컨트롤을 구성한다. 또한 차트가 기본적으로 포함되어 있고 바인딩을 통해 변화를 감지할 수 있다. http://docs.oracle.com/javafx/","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"CSS","slug":"CSS","permalink":"http://sarojaba.github.io/tags/CSS/"},{"name":"JavaFX","slug":"JavaFX","permalink":"http://sarojaba.github.io/tags/JavaFX/"},{"name":"Swing","slug":"Swing","permalink":"http://sarojaba.github.io/tags/Swing/"},{"name":"FXML","slug":"FXML","permalink":"http://sarojaba.github.io/tags/FXML/"}]},{"title":"blocking-queue","slug":"blocking-queue","date":"2012-11-25T06:35:00.000Z","updated":"2017-04-09T06:01:27.925Z","comments":true,"path":"2012/11/25/blocking-queue/","link":"","permalink":"http://sarojaba.github.io/2012/11/25/blocking-queue/","excerpt":"","text":"Queue에 요소를 추가하려고 할 때 Queue가 가득찬 경우 공간이 생길 때까지 대기한다. 반대로 요소를 삭제하려고 할 때 Queue가 비어있는 경우에도 요소가 하나라도 생길 때까지 대기한다. put()으로 집어넣고, take()로 가져간다. http://www.yunsobi.com/blog/20","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Queue","slug":"Queue","permalink":"http://sarojaba.github.io/tags/Queue/"}]},{"title":"timsort","slug":"timsort","date":"2012-11-19T13:04:00.000Z","updated":"2017-04-09T06:01:38.605Z","comments":true,"path":"2012/11/19/timsort/","link":"","permalink":"http://sarojaba.github.io/2012/11/19/timsort/","excerpt":"","text":"Python에서 처음 구현되었고, 현재 Java 7, Android에서 표준 라이브러리로 사용되는 정렬 알고리즘. 기본 아이디어는 Merge 하기 전에 미리 정렬(정방향이나 역방향)되어 있는 subarray들을 찾아내는 것이다. Java 7에서는 기본형은 Dual Pivot Quicksort를, 객체형은 Timsort를 사용한다. http://en.wikipedia.org/wiki/Timsort","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"},{"name":"Timsort","slug":"Timsort","permalink":"http://sarojaba.github.io/tags/Timsort/"},{"name":"Python","slug":"Python","permalink":"http://sarojaba.github.io/tags/Python/"}]},{"title":"벤자민-버튼의-시간은-거꾸로-간다","slug":"벤자민-버튼의-시간은-거꾸로-간다","date":"2009-04-29T07:12:00.000Z","updated":"2017-04-09T06:01:59.781Z","comments":true,"path":"2009/04/29/벤자민-버튼의-시간은-거꾸로-간다/","link":"","permalink":"http://sarojaba.github.io/2009/04/29/벤자민-버튼의-시간은-거꾸로-간다/","excerpt":"","text":"영화를 다 보고 나서 순간 멍해졌다. 영화는 나에게 무언가 메시지를 던지는데, 나는 그것조차 이해할 수 없을 정도로 삭막해진 것일까&hellip; 우선 시나리오의 소재가 너무 좋다. 벤자민은 인생을 거꾸로 살게 된다. 이미 보통 사람들의 인생의 마지막을 경험해 보았기에 인생을 진정한 의미를 찾아가게 되고 깨닫게 된다. 하지만 우리는 늙어서 더 이상 움직일 힘이 없을때 그걸 깨닫게 된다. 나도 아직 젊기에 나의 인생에 대해 간결하게 정리할 수가 없다. 의미있는 삶을 살고 싶다. 아니&hellip; 그러도록 노력할 것이다.","categories":[],"tags":[{"name":"Movie","slug":"Movie","permalink":"http://sarojaba.github.io/tags/Movie/"}]},{"title":"프로그래밍은-상상이다","slug":"프로그래밍은-상상이다","date":"2009-01-23T14:42:00.000Z","updated":"2017-04-09T06:02:23.781Z","comments":true,"path":"2009/01/23/프로그래밍은-상상이다/","link":"","permalink":"http://sarojaba.github.io/2009/01/23/프로그래밍은-상상이다/","excerpt":"","text":"임백준씨의 새로운 책이 나왔다는 사실을 접하고 곧바로 학교 도서관에 책을 신청했다. 책이 오기까지 한달이라는 시간이 걸렸지만 항상 돈이 부족한 학생이라 도서관의 신세를 지기로 했다. 그동안 기고했던 칼럼들을 모아놓은 책이어서 저자의 견해를 잘 이해할 수 있었다. 역시나 책을 읽는 내내 저자의 깊이있는 내공을 엿볼 수 있었고, 칼럼 하나하나 읽는 사이에 잠시 생각할 시간을 가질 수 있어 좋았다. 태생이 공돌이라 문학적 소양이 부족하지만 딱딱한 기술서가 아닌 이런 책들을 읽는 것이 더 좋다. 이런 책들을 많이 읽어서 나의 프로그램에서도 추상적인 냄새가 날 수 있도록 노력해야겠다.","categories":[],"tags":[{"name":"Book","slug":"Book","permalink":"http://sarojaba.github.io/tags/Book/"}]},{"title":"프로그래밍-언어론-lex와-yacc을-이용한-mini-c-컴파일러-제작","slug":"프로그래밍-언어론-lex와-yacc을-이용한-mini-c-컴파일러-제작","date":"2008-12-19T16:47:00.000Z","updated":"2017-04-09T06:02:36.129Z","comments":true,"path":"2008/12/20/프로그래밍-언어론-lex와-yacc을-이용한-mini-c-컴파일러-제작/","link":"","permalink":"http://sarojaba.github.io/2008/12/20/프로그래밍-언어론-lex와-yacc을-이용한-mini-c-컴파일러-제작/","excerpt":"","text":"개요lex와 Yacc을 이용해 간단한 연산이 가능한 Mini-C 컴파일러를 제작한다. 입력코드a = 12 + 34; print a; b = 56 - 34; print b; print a &gt; b; 결과화면 과제후기과제를 하면서 나에게는 너무 어려운 듯한 느낌이 들었다. 우선 Lex와 Yacc에 익숙해 지지까지 많은 기간이 걸렸고, 도중에 나오는 에러들에 대처하는 것에 익숙치 않았다. 참고도서의 한정된 수량으로 학교 도서관에서 대여를 못하였고, 인터넷의 여러 참고 자료를 보고 하였으나 이해하기가 어려웠다. 하지만 이렇게 과제를 마치고 보니 어느정도 이해했고 익숙해진 느낌이 든다. 사칙연산은 힘들지 않게 하였으나 변수에 값을 저장하는 방식이 이해가 안되어 시간이 많이 지연되었다. IF-ELSE문이나 FOR문 등은 여러번 시도해 보았으나 성공하지 못했다. 흡족한 마무리를 한 것은 아니지만 과제를 하면서 많은 지식을 쌓았다는 것에 만족한다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Lex","slug":"Lex","permalink":"http://sarojaba.github.io/tags/Lex/"},{"name":"Yacc","slug":"Yacc","permalink":"http://sarojaba.github.io/tags/Yacc/"}]},{"title":"warning-incompatible-implicit-declaration-of","slug":"warning-incompatible-implicit-declaration-of","date":"2008-12-12T15:00:00.000Z","updated":"2017-04-09T06:02:59.413Z","comments":true,"path":"2008/12/13/warning-incompatible-implicit-declaration-of/","link":"","permalink":"http://sarojaba.github.io/2008/12/13/warning-incompatible-implicit-declaration-of/","excerpt":"","text":"GCC 컴파일을 하다가 다음과 같은 경고가 떴다. warning : incompatible implicit declaration of built-in function 해결책은 해당 함수의 선언이 포함된 헤더파일을 include 해주면 된다.","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"GCC","slug":"GCC","permalink":"http://sarojaba.github.io/tags/GCC/"}]},{"title":"ubuntu-qt4-eclipse-개발환경-구축하기","slug":"ubuntu-qt4-eclipse-개발환경-구축하기","date":"2008-12-08T15:00:00.000Z","updated":"2017-04-09T06:03:15.321Z","comments":true,"path":"2008/12/09/ubuntu-qt4-eclipse-개발환경-구축하기/","link":"","permalink":"http://sarojaba.github.io/2008/12/09/ubuntu-qt4-eclipse-개발환경-구축하기/","excerpt":"","text":"시냅틱으로 Qt4 관련 패키지 모두 설치한다. 이클립스 Qt 플러그인을 받는다.http://trolltech.com/developer/eclipse-integration Window -&gt; Preference -&gt; Qt -&gt; Add 를 선택하고&hellip;Version Name : Qt4Bin Path : /usr/binInclude Path : /usr/include/qt4 프로젝트를 생성해 신나게 코딩한다. ㅋ","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Eclipse","slug":"Eclipse","permalink":"http://sarojaba.github.io/tags/Eclipse/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://sarojaba.github.io/tags/Ubuntu/"},{"name":"Qt","slug":"Qt","permalink":"http://sarojaba.github.io/tags/Qt/"}]},{"title":"바이트-배열을-16진수로-변환하기","slug":"바이트-배열을-16진수로-변환하기","date":"2008-11-12T15:00:00.000Z","updated":"2017-04-09T06:03:35.005Z","comments":true,"path":"2008/11/13/바이트-배열을-16진수로-변환하기/","link":"","permalink":"http://sarojaba.github.io/2008/11/13/바이트-배열을-16진수로-변환하기/","excerpt":"","text":"출처: Beginning Cryptography with Java - Wrox public static String toHex(byte[] data) { StringBuffer buf = new StringBuffer(); for(int i = 0; i &lt; data.length; i++) { int v = data[i] &amp; 0xff; buf.append(digits.charAt(v &gt;&gt; 4)); buf.append(digits.charAt(v &amp; 0xf)); } return buf.toString(); }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]},{"title":"문자열이-숫자인지-판단하는-메소드","slug":"문자열이-숫자인지-판단하는-메소드","date":"2008-11-12T15:00:00.000Z","updated":"2017-04-09T06:03:54.721Z","comments":true,"path":"2008/11/13/문자열이-숫자인지-판단하는-메소드/","link":"","permalink":"http://sarojaba.github.io/2008/11/13/문자열이-숫자인지-판단하는-메소드/","excerpt":"","text":"출처: http://www.devx.com/tips/Tip/39748?trk=DXRSS_JAVA public static boolean isNumber(String s) { try { new Double(s); return true; } catch(Exception ex) { return false; } }","categories":[],"tags":[{"name":"Programming","slug":"Programming","permalink":"http://sarojaba.github.io/tags/Programming/"},{"name":"Java","slug":"Java","permalink":"http://sarojaba.github.io/tags/Java/"}]}]}