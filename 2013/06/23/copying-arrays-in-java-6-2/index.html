<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> copying-arrays-in-java-6-2 · 사로자바의 블로그</title><meta name="description" content="copying-arrays-in-java-6-2 - 사로자바"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://sarojaba.github.io/atom.xml" title="사로자바의 블로그"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li><li class="nav-list-item"><a href="https://www.facebook.com/sarojaba" target="_blank" class="nav-list-link">FACKBOOK</a></li><li class="nav-list-item"><a href="https://github.com/sarojaba" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="http://codepen.io/sarojaba" target="_blank" class="nav-list-link">CODEPEN</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">copying-arrays-in-java-6-2</h1><div class="post-info">Jun 23, 2013</div><div class="post-content"><p>자바 6에서는 더 이상 이런 역할의 유틸리티 메소드가 필요가 없다. 썬은 배열의 복사를 위한 직접 지원을 소개한다. 썬은 새로운 Arrays 클래스의 오버로드된 메소드인 copyOf 를 정의한다.</p>
<pre><code>targetArray = Arrays.copyOf(sourceArray, length);
`&lt;/pre&gt;

여기서는 copyOf 메소드의 행동을 시연해보기 위해 JUnit test를 몇 개 사용하였다. 여기에 기본 기능을 보여주는 첫번째 테스트가 있다.

&lt;pre&gt;`@Test
public void genericArrayCopyOf() {
    Number[] source = { new Double(5.0), new Double(10.0) };
    Number[] target = Arrays.copyOf(source, source.length);
    assertEquals(source, target);
}
`&lt;/pre&gt;

JUnit 4의 새로운 특징중의 하나는 assertEquals를 사용한 두개의 배열의 비교 능력이다. 그 작업을 할 때, JUnit는 첫째로 각 배열의 크기를 비교한다. 만약 두 배열이 같다면 JUnit은 equals을 사용하여 각각의 요소들을 비교한다. 두 배열이 다르면, JUnit은 failure 메시지를 나타내어 부등호 값을 보여준다.

자바는 두개의 다른 변수로 기본형 타입을 지원을 위해 copyOf 를 오버로드한다. 또 다른 테스트는 원본의 범위를 지원할 수 있는 방법을 보여준다.

&lt;pre&gt;`@Test
public void copyOfWithRange() {
    String[] source = { &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot; };
    String[] target = Arrays.copyOfRange(source, 2, 4);
    assertEquals(new String[] { &quot;2&quot;, &quot;3&quot; }, target);
}

@Test
public void primitives() {
    int[] source = { 0, 1, 2, 3, 4 };
    int[] target = Arrays.copyOfRange(source, 4, 5);
    assertEqualsPrim(new int[] { 4 }, target);
}
`&lt;/pre&gt;

JUnit 4는 기본형 타입을 가지고 있는 두 배열을 비교할 수 없기에 assertEqualsPrim 메소드를 작성했다. It contains only a version that compares two Object arrays. assertEquals 를 이용해 두 기본형 타입의 배열을 비교하는 것은 자바가 메모리 비교를 하는 것을 의미한다. 별거 아니게, assertEqualsPrim 를 작성하는 것은 아주 쉽다.

&lt;pre&gt;`static void assertEqualsPrim(int[] expected, int[] actual) {

    if (expected.length != actual.length)
        fail(String.format(&quot;expected length = %s, actual length = %s&quot;,
            expected.length, actual.length));

    for (int i = 0; i &lt; expected.length; i++) {
        if (expected[i] != actual[i])
            fail(String.format(
                &quot;mismatch at index %d: expected [%s] but was [%s]&quot;, i,
                expected[i], actual[i]));
    }
}
`&lt;/pre&gt;

What if I want the new array to be of a new, subclass type? The following test fails:

&lt;pre&gt;`@Test
public void genericArrayCopyOfWithNewType() {
    Number[] source = { new Double(5.0), new Double(10.0) };
    Double[] target = (Double[])Arrays.copyOf(source, source.length);
    assertEquals(source, target); // fail!
}
`&lt;/pre&gt;

But Java 6 allows me to declare a new type for the target array on a copy:

&lt;pre&gt;`@Test
public void genericArrayCopyOfWithNewType() {
    Number[] source = { new Double(5.0), new Double(10.0) };
    Double[] target = Arrays.copyOf(source, source.length, Double[].class);
    assertEquals(source, target);
}
</code></pre></div></article></div></main><footer><div class="paginator"><a href="/2013/06/20/moon-night/" class="prev">PREV</a><a href="/2013/06/24/미인도/" class="next">NEXT</a></div><div id="disqus_thread"></div><script>var disqus_shortname = 'sarojaba';
var disqus_identifier = '2013/06/23/copying-arrays-in-java-6-2/';
var disqus_title = 'copying-arrays-in-java-6-2';
var disqus_url = 'http://sarojaba.github.io/2013/06/23/copying-arrays-in-java-6-2/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//sarojaba.disqus.com/count.js" async></script><div class="copyright"><p>© 2015 - 2017 <a href="http://sarojaba.github.io">사로자바</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>